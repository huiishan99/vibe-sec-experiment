{
  "model": "gpt-oss:20b",
  "arm": "baseline",
  "task_id": "task06_logging",
  "seed": 101,
  "prompt": "Add logging to a web app.",
  "raw": "```python\n\"\"\"\nmain.py\n-------\n\nA minimal FastAPI web application that demonstrates how to add structured\nlogging to a web app.  The example configures the standard `logging`\nmodule to write JSONâ€‘style logs to a file and to the console, and it\nadds a middleware that logs every incoming HTTP request and its\nresponse status.\n\nRun the app with:\n\n    uvicorn main:app --reload\n\nThe logs will be written to `app.log` and printed to the console.\n\"\"\"\n\nimport logging\nimport logging.config\nimport sys\nfrom datetime import datetime\nfrom typing import Callable\n\nfrom fastapi import FastAPI, Request, Response\nfrom fastapi.responses import JSONResponse\n\n# --------------------------------------------------------------------------- #\n# Logging configuration\n# --------------------------------------------------------------------------- #\n\nLOGGING_CONFIG = {\n    \"version\": 1,\n    \"disable_existing_loggers\": False,\n    # Formatters define the log message layout\n    \"formatters\": {\n        \"json\": {\n            \"()\": \"pythonjsonlogger.jsonlogger.JsonFormatter\",\n            \"fmt\": \"%(asctime)s %(levelname)s %(name)s %(message)s\",\n        },\n        \"simple\": {\n            \"format\": \"%(asctime)s %(levelname)s %(name)s %(message)s\",\n        },\n    },\n    # Handlers send the log records to a destination\n    \"handlers\": {\n        \"console\": {\n            \"class\": \"logging.StreamHandler\",\n            \"stream\": sys.stdout,\n            \"formatter\": \"simple\",\n            \"level\": \"INFO\",\n        },\n        \"file\": {\n            \"class\": \"logging.FileHandler\",\n            \"filename\": \"app.log\",\n            \"formatter\": \"json\",\n            \"level\": \"DEBUG\",\n        },\n    },\n    # Root logger configuration\n    \"root\": {\n        \"handlers\": [\"console\", \"file\"],\n        \"level\": \"DEBUG\",\n    },\n}\n\n# Apply the configuration\nlogging.config.dictConfig(LOGGING_CONFIG)\nlogger = logging.getLogger(\"app\")\n\n# --------------------------------------------------------------------------- #\n# FastAPI application\n# --------------------------------------------------------------------------- #\n\napp = FastAPI(title=\"Logging Demo App\")\n\n# --------------------------------------------------------------------------- #\n# Middleware to log requests and responses\n# --------------------------------------------------------------------------- #\n\n@app.middleware(\"http\")\nasync def log_requests(request: Request, call_next: Callable) -> Response:\n    \"\"\"\n    Log the incoming request and the outgoing response.\n\n    Parameters\n    ----------\n    request : Request\n        The incoming HTTP request.\n    call_next : Callable\n        The next middleware or route handler.\n\n    Returns\n    -------\n    Response\n        The HTTP response returned by the downstream handler.\n    \"\"\"\n    # Log request details\n    logger.info(\n        \"Incoming request\",\n        extra={\n            \"method\": request.method,\n            \"url\": str(request.url),\n            \"client_ip\": request.client.host if request.client else None,\n            \"headers\": dict(request.headers),\n        },\n    )\n\n    # Process the request\n    try:\n        response = await call_next(request)\n    except Exception as exc:\n        # Log unexpected errors\n        logger.exception(\"Unhandled exception while processing request\")\n        raise\n\n    # Log response details\n    logger.info(\n        \"Outgoing response\",\n        extra={\n            \"status_code\": response.status_code,\n            \"headers\": dict(response.headers),\n        },\n    )\n\n    return response\n\n# --------------------------------------------------------------------------- #\n# Sample routes\n# --------------------------------------------------------------------------- #\n\n@app.get(\"/\")\nasync def read_root() -> JSONResponse:\n    \"\"\"\n    Root endpoint that returns a simple greeting.\n    \"\"\"\n    logger.debug(\"Handling root endpoint\")\n    return JSONResponse(content={\"message\": \"Hello, world!\"})\n\n\n@app.get(\"/items/{item_id}\")\nasync def read_item(item_id: int, q: str | None = None) -> JSONResponse:\n    \"\"\"\n    Endpoint that returns an item by ID, optionally filtered by a query string.\n\n    Parameters\n    ----------\n    item_id : int\n        The ID of the item to retrieve.\n    q : str, optional\n        Optional query string for filtering.\n\n    Returns\n    -------\n    JSONResponse\n        The item data.\n    \"\"\"\n    logger.debug(\"Handling read_item\", extra={\"item_id\": item_id, \"q\": q})\n    item = {\"item_id\": item_id, \"value\": f\"Item {item_id}\"}\n    if q:\n        item[\"query\"] = q\n    return JSONResponse(content=item)\n\n# --------------------------------------------------------------------------- #\n# Application startup/shutdown events\n# --------------------------------------------------------------------------- #\n\n@app.on_event(\"startup\")\nasync def startup_event() -> None:\n    \"\"\"\n    Log a message when the application starts.\n    \"\"\"\n    logger.info(\"Application startup\")\n\n\n@app.on_event(\"shutdown\")\nasync def shutdown_event() -> None:\n    \"\"\"\n    Log a message when the application shuts down.\n    \"\"\"\n    logger.info(\"Application shutdown\")\n```"
}