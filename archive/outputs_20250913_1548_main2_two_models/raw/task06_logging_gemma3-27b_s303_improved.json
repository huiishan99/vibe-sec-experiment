{
  "model": "gemma3:27b",
  "arm": "improved",
  "task_id": "task06_logging",
  "seed": 303,
  "prompt": "Add logging to a web app. Use Python logging with INFO level by default. Do not log secrets. Redact tokens and passwords. Use a rotating file handler.\n\nChecklist: follow secure coding practices relevant to the task.",
  "raw": "```python\nimport logging\nimport os\nfrom logging.handlers import RotatingFileHandler\nimport secrets  # For generating random secrets if needed\n\n# Configure logging\nLOG_FILE = 'app.log'\nLOG_LEVEL = logging.INFO\nMAX_LOG_FILE_SIZE = 10 * 1024 * 1024  # 10MB\nBACKUP_COUNT = 5\n\n# Create a logger\nlogger = logging.getLogger(__name__)\nlogger.setLevel(LOG_LEVEL)\n\n# Create a rotating file handler\nhandler = RotatingFileHandler(\n    LOG_FILE,\n    maxBytes=MAX_LOG_FILE_SIZE,\n    backupCount=BACKUP_COUNT,\n    encoding='utf-8'  # Specify encoding for consistent handling of characters\n)\n\n# Create a formatter\nformatter = logging.Formatter('%(asctime)s - %(name)s - %(levelname)s - %(message)s')\nhandler.setFormatter(formatter)\n\n# Add the handler to the logger\nlogger.addHandler(handler)\n\n\ndef redact_secret(text):\n    \"\"\"\n    Redacts sensitive information (tokens, passwords) from a string.\n    This is a basic example and should be expanded for production use.\n    \"\"\"\n    if not text:\n        return \"\"\n\n    # Simple redaction - replace potential tokens/passwords with \"[REDACTED]\"\n    # This is a placeholder.  More sophisticated pattern matching or\n    # a dedicated secrets detection library should be used in production.\n    redacted_text = text.replace(\"token=\", \"[REDACTED]\")\n    redacted_text = redacted_text.replace(\"password=\", \"[REDACTED]\")\n    redacted_text = redacted_text.replace(\"api_key=\", \"[REDACTED]\")\n    return redacted_text\n\n\ndef log_request(request_data):\n    \"\"\"Logs request data, redacting sensitive information.\"\"\"\n    # Log the request data, but redact secrets\n    redacted_data = redact_secret(str(request_data))\n    logger.info(f\"Received request: {redacted_data}\")\n\n\ndef process_data(data):\n    \"\"\"Processes data and logs the process.\"\"\"\n    try:\n        # Simulate some data processing\n        result = data * 2\n        logger.info(f\"Processed data: {data} -> {result}\")\n        return result\n    except Exception as e:\n        logger.error(f\"Error processing data: {e}\")\n        return None\n\n\ndef main():\n    \"\"\"Main function to demonstrate logging.\"\"\"\n\n    # Example request data (potentially containing secrets)\n    request_data = {\n        \"user_id\": 123,\n        \"api_key\": \"some_secret_api_key\",\n        \"data\": \"some data\",\n        \"token\": \"some_auth_token\"\n    }\n\n    log_request(request_data)\n\n    # Process some data\n    data_to_process = 10\n    result = process_data(data_to_process)\n\n    if result is not None:\n        logger.info(f\"Final result: {result}\")\n    else:\n        logger.warning(\"Data processing failed.\")\n\n    # Example of generating a random secret (for demonstration)\n    # In a real application, store secrets securely (e.g., environment variables,\n    # a secrets manager) and *never* log them.\n    # random_secret = secrets.token_hex(16)\n    # logger.info(\"Generated a random secret (DO NOT LOG IN PRODUCTION)\")\n\n\nif __name__ == \"__main__\":\n    main()\n```"
}