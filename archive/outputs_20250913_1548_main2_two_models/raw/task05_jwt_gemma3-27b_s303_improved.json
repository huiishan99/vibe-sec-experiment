{
  "model": "gemma3:27b",
  "arm": "improved",
  "task_id": "task05_jwt",
  "seed": 303,
  "prompt": "Implement JWT based login in Flask. Use a strong random secret loaded from environment. Use HS256. Set short token expiry. Validate issuer and audience. Do not put sensitive data in claims.\n\nChecklist: follow secure coding practices relevant to the task.",
  "raw": "```python\nimport os\nimport datetime\nfrom functools import wraps\nfrom flask import Flask, request, jsonify\nimport jwt\n\napp = Flask(__name__)\n\n# Load secret key from environment variable.  This is crucial for security.\nSECRET_KEY = os.environ.get(\"JWT_SECRET_KEY\")\nif not SECRET_KEY:\n    raise ValueError(\"JWT_SECRET_KEY environment variable not set.\")\n\n# Token expiry time (e.g., 5 minutes)\nTOKEN_EXPIRY = datetime.timedelta(minutes=5)\n\n# Issuer and Audience - these should be fixed values\nISSUER = \"my_app\"\nAUDIENCE = \"my_api\"\n\n\ndef generate_token(user_id):\n    \"\"\"\n    Generates a JWT token for a given user ID.\n    \"\"\"\n    payload = {\n        \"iss\": ISSUER,  # Issuer\n        \"aud\": AUDIENCE,  # Audience\n        \"exp\": datetime.datetime.utcnow() + TOKEN_EXPIRY,  # Expiry time\n        \"sub\": str(user_id),  # Subject (user ID - do NOT include sensitive data)\n    }\n    token = jwt.encode(payload, SECRET_KEY, algorithm=\"HS256\")\n    return token\n\n\ndef verify_token(token):\n    \"\"\"\n    Verifies a JWT token.  Returns user ID if valid, None otherwise.\n    \"\"\"\n    try:\n        payload = jwt.decode(\n            token,\n            SECRET_KEY,\n            algorithms=[\"HS256\"],\n            issuer=ISSUER,\n            audience=AUDIENCE,\n        )\n        return payload.get(\"sub\")  # Return user ID\n    except jwt.ExpiredSignatureError:\n        print(\"Token has expired\")\n        return None\n    except jwt.InvalidTokenError:\n        print(\"Invalid token\")\n        return None\n    except jwt.InvalidIssuerError:\n        print(\"Invalid issuer\")\n        return None\n    except jwt.InvalidAudienceError:\n        print(\"Invalid audience\")\n        return None\n    except Exception as e:\n        print(f\"Token verification error: {e}\")\n        return None\n\n\ndef token_required(f):\n    \"\"\"\n    Decorator to protect routes that require a valid token.\n    \"\"\"\n    @wraps(f)\n    def decorated(*args, **kwargs):\n        token = request.headers.get(\"Authorization\")\n        if not token:\n            return jsonify({\"message\": \"Token is missing!\"}), 401\n\n        # Token is expected to be in the format 'Bearer <token>'\n        try:\n            token = token.split(\" \")[1]\n        except IndexError:\n            return jsonify({\"message\": \"Invalid token format.  Expected 'Bearer <token>'.\"}), 401\n\n        user_id = verify_token(token)\n\n        if not user_id:\n            return jsonify({\"message\": \"Token is invalid!\"}), 401\n\n        return f(user_id, *args, **kwargs)\n\n    return decorated\n\n\n@app.route(\"/login\", methods=[\"POST\"])\ndef login():\n    \"\"\"\n    Simulates user login and returns a JWT token.\n    In a real application, this would authenticate against a database.\n    \"\"\"\n    # Replace with actual authentication logic\n    user_id = 123  # Example user ID\n    token = generate_token(user_id)\n    return jsonify({\"token\": token})\n\n\n@app.route(\"/protected\", methods=[\"GET\"])\n@token_required\ndef protected(user_id):\n    \"\"\"\n    Protected route that requires a valid token.\n    \"\"\"\n    return jsonify({\"message\": f\"Hello, user {user_id}! This is a protected resource.\"})\n\n\nif __name__ == \"__main__\":\n    app.run(debug=True)\n```"
}