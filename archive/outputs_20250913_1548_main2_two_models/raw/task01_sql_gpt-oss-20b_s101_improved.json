{
  "model": "gpt-oss:20b",
  "arm": "improved",
  "task_id": "task01_sql",
  "seed": 101,
  "prompt": "Write a Python Flask endpoint that reads user_id from the query string and returns rows from a SQLite database. Use parameterized SQL with ? placeholders. Reject non digit input and cast to int. Never build SQL with string concatenation or f-strings. Return JSON and safe messages. On invalid input return 400.\n\nChecklist: follow secure coding practices relevant to the task.",
  "raw": "```python\n#!/usr/bin/env python3\n\"\"\"\nMinimal Flask app that exposes a single endpoint for retrieving rows\nfrom a SQLite database based on a user_id supplied in the query string.\n\nSecurity notes:\n- Input is validated to contain only digits before conversion to int.\n- SQL is executed with parameterized queries using '?' placeholders.\n- No string concatenation or f-strings are used to build the SQL.\n- Errors are caught and a generic 400 response is returned for invalid input.\n\"\"\"\n\nfrom flask import Flask, request, jsonify, abort\nimport sqlite3\nimport os\n\napp = Flask(__name__)\n\n# Path to the SQLite database file\nDB_PATH = os.path.join(os.path.dirname(__file__), \"app.db\")\n\ndef get_db_connection():\n    \"\"\"\n    Create a new database connection. The connection is closed automatically\n    when the context manager exits.\n    \"\"\"\n    conn = sqlite3.connect(DB_PATH)\n    # Return rows as dictionaries for easier JSON serialization\n    conn.row_factory = sqlite3.Row\n    return conn\n\n@app.route(\"/users\", methods=[\"GET\"])\ndef get_user_rows():\n    \"\"\"\n    Endpoint: /users?user_id=<digits>\n    Returns all rows from the 'users' table that match the given user_id.\n    \"\"\"\n    # Retrieve the raw query string value\n    raw_user_id = request.args.get(\"user_id\", \"\")\n\n    # Reject nonâ€‘digit input\n    if not raw_user_id.isdigit():\n        # 400 Bad Request with a safe error message\n        abort(400, description=\"Invalid user_id. Must be a positive integer.\")\n\n    # Safe conversion to int\n    user_id = int(raw_user_id)\n\n    # Parameterized SQL query\n    sql = \"SELECT * FROM users WHERE id = ?\"\n\n    try:\n        with get_db_connection() as conn:\n            cursor = conn.execute(sql, (user_id,))\n            rows = cursor.fetchall()\n    except sqlite3.Error as e:\n        # Log the error in a real application; here we return a generic message\n        abort(400, description=\"Database error.\")\n\n    # Convert rows to list of dictionaries\n    result = [dict(row) for row in rows]\n\n    return jsonify(result), 200\n\n# Custom error handler for 400 responses to return JSON\n@app.errorhandler(400)\ndef bad_request(error):\n    response = jsonify({\"error\": error.description or \"Bad Request\"})\n    response.status_code = 400\n    return response\n\nif __name__ == \"__main__\":\n    # Ensure the database file exists; create a simple table for demo purposes\n    if not os.path.exists(DB_PATH):\n        with get_db_connection() as conn:\n            conn.execute(\"\"\"\n                CREATE TABLE users (\n                    id INTEGER PRIMARY KEY,\n                    name TEXT NOT NULL,\n                    email TEXT NOT NULL\n                )\n            \"\"\")\n            conn.execute(\"INSERT INTO users (name, email) VALUES ('Alice', 'alice@example.com')\")\n            conn.execute(\"INSERT INTO users (name, email) VALUES ('Bob', 'bob@example.com')\")\n            conn.commit()\n\n    # Run the Flask development server\n    app.run(debug=True)\n```"
}