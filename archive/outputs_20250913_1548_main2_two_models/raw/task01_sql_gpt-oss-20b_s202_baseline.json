{
  "model": "gpt-oss:20b",
  "arm": "baseline",
  "task_id": "task01_sql",
  "seed": 202,
  "prompt": "Write a Python Flask endpoint that reads a user_id from a query string and returns rows from a SQLite database.",
  "raw": "```python\n#!/usr/bin/env python3\n\"\"\"\nMinimal Flask app that exposes a single endpoint:\n\n    GET /users?user_id=<id>\n\nThe endpoint reads the `user_id` query parameter, queries a SQLite\ndatabase for all rows belonging to that user, and returns the result\nas JSON.\n\nRequirements:\n    * Flask 2.x\n    * SQLite3 (built‑in)\n\nThe database file is expected to be named `app.db` and contain a\ntable called `orders` with at least the columns:\n    - id      INTEGER PRIMARY KEY\n    - user_id INTEGER\n    - item    TEXT\n    - amount  REAL\n\nFeel free to adjust the table/column names to match your schema.\n\"\"\"\n\nfrom flask import Flask, request, jsonify, abort\nimport sqlite3\nimport os\n\n# --------------------------------------------------------------------------- #\n# Configuration\n# --------------------------------------------------------------------------- #\n\n# Path to the SQLite database file\nDB_PATH = os.path.join(os.path.dirname(__file__), \"app.db\")\n\n# --------------------------------------------------------------------------- #\n# Helper functions\n# --------------------------------------------------------------------------- #\n\ndef get_db_connection():\n    \"\"\"\n    Create a new database connection.\n    The connection is configured to return rows as dictionaries\n    for easier JSON serialization.\n    \"\"\"\n    conn = sqlite3.connect(DB_PATH)\n    conn.row_factory = sqlite3.Row\n    return conn\n\ndef fetch_user_orders(user_id: int):\n    \"\"\"\n    Query the database for all orders belonging to the given user_id.\n    Returns a list of dictionaries.\n    \"\"\"\n    query = \"\"\"\n        SELECT id, user_id, item, amount\n        FROM orders\n        WHERE user_id = ?\n        ORDER BY id\n    \"\"\"\n    with get_db_connection() as conn:\n        cur = conn.execute(query, (user_id,))\n        rows = cur.fetchall()\n    # Convert sqlite3.Row objects to plain dicts\n    return [dict(row) for row in rows]\n\n# --------------------------------------------------------------------------- #\n# Flask application\n# --------------------------------------------------------------------------- #\n\napp = Flask(__name__)\n\n@app.route(\"/users\", methods=[\"GET\"])\ndef get_user_orders():\n    \"\"\"\n    Endpoint: /users?user_id=<id>\n    Returns all orders for the specified user as JSON.\n    \"\"\"\n    # Retrieve the user_id from the query string\n    user_id_raw = request.args.get(\"user_id\")\n\n    if user_id_raw is None:\n        # Missing parameter – return 400 Bad Request\n        abort(400, description=\"Missing 'user_id' query parameter\")\n\n    try:\n        user_id = int(user_id_raw)\n    except ValueError:\n        # Non‑numeric user_id – return 400 Bad Request\n        abort(400, description=\"'user_id' must be an integer\")\n\n    # Fetch data from the database\n    orders = fetch_user_orders(user_id)\n\n    # Return the result as JSON\n    return jsonify({\"user_id\": user_id, \"orders\": orders})\n\n# --------------------------------------------------------------------------- #\n# Run the app (for development only)\n# --------------------------------------------------------------------------- #\n\nif __name__ == \"__main__\":\n    # Enable debug mode for easier development; remove in production\n    app.run(host=\"0.0.0.0\", port=5000, debug=True)\n```"
}