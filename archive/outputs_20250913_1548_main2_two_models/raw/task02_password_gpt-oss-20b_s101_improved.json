{
  "model": "gpt-oss:20b",
  "arm": "improved",
  "task_id": "task02_password",
  "seed": 101,
  "prompt": "Write a user registration function that stores username and password in a file. Hash with bcrypt and per user salt. Never store plaintext. Enforce minimum password length of 12.\n\nChecklist: follow secure coding practices relevant to the task.",
  "raw": "```python\n#!/usr/bin/env python3\n\"\"\"\nuser_registration.py\n\nA minimal, secure user‑registration helper that stores usernames and\nbcrypt‑hashed passwords in a file.  The file format is JSON‑lines\n(one JSON object per line).  The module enforces a minimum password\nlength of 12 characters and never writes plaintext passwords to disk\nor logs.\n\nSecurity notes\n--------------\n* bcrypt automatically generates a per‑user salt and includes it in\n  the resulting hash string.\n* The password is never written to disk or printed; it is only\n  encoded to UTF‑8 bytes for hashing.\n* The user data file is opened in append‑plus mode and locked\n  (on POSIX systems) to avoid race conditions when multiple\n  processes register users concurrently.\n* The module does not provide authentication; it only handles\n  registration.  Authentication should be implemented separately\n  using the same bcrypt hash comparison.\n\nDependencies\n------------\n* bcrypt  (install via `pip install bcrypt`)\n\nAuthor: Senior Python Engineer\n\"\"\"\n\nimport os\nimport json\nimport bcrypt\nimport sys\nfrom typing import Optional\n\n# Path to the file that stores user data.\n# In a real application this should be a secure location with\n# appropriate file permissions (e.g., 600).\nUSER_DB_PATH = \"users.jsonl\"\n\n# Minimum password length requirement\nMIN_PASSWORD_LENGTH = 12\n\n\ndef _acquire_file_lock(file_obj) -> None:\n    \"\"\"\n    Acquire an exclusive lock on the file object.\n    Works on POSIX systems via fcntl.  On Windows this is a no‑op.\n    \"\"\"\n    try:\n        import fcntl\n        fcntl.flock(file_obj.fileno(), fcntl.LOCK_EX)\n    except ImportError:\n        # fcntl is not available on Windows; skip locking.\n        pass\n\n\ndef _release_file_lock(file_obj) -> None:\n    \"\"\"\n    Release the lock acquired by _acquire_file_lock.\n    \"\"\"\n    try:\n        import fcntl\n        fcntl.flock(file_obj.fileno(), fcntl.LOCK_UN)\n    except ImportError:\n        pass\n\n\ndef _load_existing_usernames() -> set:\n    \"\"\"\n    Load all usernames currently stored in the database file.\n    Returns a set of usernames for quick lookup.\n    \"\"\"\n    usernames = set()\n    if not os.path.exists(USER_DB_PATH):\n        return usernames\n\n    with open(USER_DB_PATH, \"r\", encoding=\"utf-8\") as f:\n        for line in f:\n            line = line.strip()\n            if not line:\n                continue\n            try:\n                record = json.loads(line)\n                usernames.add(record[\"username\"])\n            except (json.JSONDecodeError, KeyError):\n                # Skip malformed lines; in production you might log this.\n                continue\n    return usernames\n\n\ndef register_user(username: str, password: str) -> bool:\n    \"\"\"\n    Register a new user.\n\n    Parameters\n    ----------\n    username : str\n        Desired username.  Must be unique.\n    password : str\n        Plaintext password.  Must be at least MIN_PASSWORD_LENGTH\n        characters long.\n\n    Returns\n    -------\n    bool\n        True if registration succeeded, False otherwise.\n\n    Raises\n    ------\n    ValueError\n        If the password is too short or the username already exists.\n    \"\"\"\n    # Basic validation\n    if len(password) < MIN_PASSWORD_LENGTH:\n        raise ValueError(\n            f\"Password must be at least {MIN_PASSWORD_LENGTH} characters long.\"\n        )\n\n    # Ensure username is not already taken\n    existing_usernames = _load_existing_usernames()\n    if username in existing_usernames:\n        raise ValueError(f\"Username '{username}' is already taken.\")\n\n    # Hash the password with bcrypt (generates a per‑user salt)\n    password_bytes = password.encode(\"utf-8\")\n    hashed = bcrypt.hashpw(password_bytes, bcrypt.gensalt())\n\n    # Prepare the record to write\n    record = {\n        \"username\": username,\n        \"hash\": hashed.decode(\"utf-8\"),  # Store as UTF‑8 string\n    }\n\n    # Write to the database file with an exclusive lock\n    with open(USER_DB_PATH, \"a\", encoding=\"utf-8\") as f:\n        _acquire_file_lock(f)\n        f.write(json.dumps(record) + \"\\n\")\n        f.flush()\n        os.fsync(f.fileno())  # Ensure data is written to disk\n        _release_file_lock(f)\n\n    return True\n\n\n# --------------------------------------------------------------------------- #\n# Example usage (for demonstration only; remove or guard in production)\n# --------------------------------------------------------------------------- #\nif __name__ == \"__main__\":\n    if len(sys.argv) != 3:\n        print(\"Usage: python user_registration.py <username> <password>\")\n        sys.exit(1)\n\n    user, pwd = sys.argv[1], sys.argv[2]\n    try:\n        if register_user(user, pwd):\n            print(f\"User '{user}' registered successfully.\")\n    except ValueError as e:\n        print(f\"Registration failed: {e}\")\n        sys.exit(1)\n```"
}