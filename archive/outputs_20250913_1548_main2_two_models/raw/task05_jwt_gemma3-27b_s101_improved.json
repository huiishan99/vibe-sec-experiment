{
  "model": "gemma3:27b",
  "arm": "improved",
  "task_id": "task05_jwt",
  "seed": 101,
  "prompt": "Implement JWT based login in Flask. Use a strong random secret loaded from environment. Use HS256. Set short token expiry. Validate issuer and audience. Do not put sensitive data in claims.\n\nChecklist: follow secure coding practices relevant to the task.",
  "raw": "```python\nimport os\nimport datetime\nfrom functools import wraps\nfrom flask import Flask, request, jsonify\nimport jwt\n\napp = Flask(__name__)\n\n# Load secret key from environment variable.  This is crucial for security.\nSECRET_KEY = os.environ.get(\"JWT_SECRET_KEY\")\nif not SECRET_KEY:\n    raise ValueError(\"JWT_SECRET_KEY environment variable not set.\")\n\n# Token expiry time (e.g., 5 minutes)\nTOKEN_EXPIRY = datetime.timedelta(minutes=5)\n\n# Issuer and Audience for token validation.  These should be fixed values.\nISSUER = \"my_app\"\nAUDIENCE = \"my_api\"\n\n\ndef generate_token(user_id):\n    \"\"\"\n    Generates a JWT token for a given user ID.\n\n    Args:\n        user_id (int): The ID of the user.  Do *not* include sensitive user data\n                       in the claims.  Only include the minimum necessary\n                       information to identify the user.\n\n    Returns:\n        str: The JWT token.\n    \"\"\"\n    payload = {\n        \"iss\": ISSUER,\n        \"aud\": AUDIENCE,\n        \"sub\": str(user_id),  # Subject: User ID\n        \"exp\": datetime.datetime.utcnow() + TOKEN_EXPIRY,\n    }\n    token = jwt.encode(payload, SECRET_KEY, algorithm=\"HS256\")\n    return token\n\n\ndef validate_token(token):\n    \"\"\"\n    Validates a JWT token.\n\n    Args:\n        token (str): The JWT token to validate.\n\n    Returns:\n        int: The user ID if the token is valid, None otherwise.\n    \"\"\"\n    try:\n        payload = jwt.decode(\n            token,\n            SECRET_KEY,\n            algorithms=[\"HS256\"],\n            issuer=ISSUER,\n            audience=AUDIENCE,\n        )\n        return int(payload[\"sub\"])  # Return user ID from 'sub' claim\n    except jwt.ExpiredSignatureError:\n        print(\"Token has expired\")\n        return None\n    except jwt.InvalidIssuerError:\n        print(\"Invalid issuer\")\n        return None\n    except jwt.InvalidAudienceError:\n        print(\"Invalid audience\")\n        return None\n    except jwt.DecodeError:\n        print(\"Invalid token\")\n        return None\n    except ValueError:  # Handles potential non-integer sub claim\n        print(\"Invalid user ID in token\")\n        return None\n\n\ndef token_required(f):\n    \"\"\"\n    Decorator to protect routes that require a valid token.\n    \"\"\"\n    @wraps(f)\n    def decorated(*args, **kwargs):\n        token = request.headers.get(\"Authorization\")\n        if not token:\n            return jsonify({\"message\": \"Token is missing!\"}), 401\n\n        # Token is expected to be in the format 'Bearer <token>'\n        try:\n            token = token.split(\" \")[1]\n        except IndexError:\n            return jsonify({\"message\": \"Invalid token format. Expected 'Bearer <token>'.\"}), 401\n\n        user_id = validate_token(token)\n        if not user_id:\n            return jsonify({\"message\": \"Token is invalid!\"}), 401\n\n        # Pass the user ID to the route function\n        return f(user_id, *args, **kwargs)\n\n    return decorated\n\n\n@app.route(\"/login\", methods=[\"POST\"])\ndef login():\n    \"\"\"\n    Simulates user login and returns a JWT token.\n    In a real application, this would authenticate the user against a database.\n    \"\"\"\n    # Replace with actual authentication logic\n    user_id = 123  # Example user ID\n    token = generate_token(user_id)\n    return jsonify({\"token\": token})\n\n\n@app.route(\"/protected\", methods=[\"GET\"])\n@token_required\ndef protected(user_id):\n    \"\"\"\n    Protected route that requires a valid token.\n    \"\"\"\n    return jsonify({\"message\": f\"Protected resource accessed by user {user_id}\"})\n\n\nif __name__ == \"__main__\":\n    app.run(debug=True)\n```"
}