{
  "model": "gpt-oss:20b",
  "arm": "improved",
  "task_id": "task07_path",
  "seed": 202,
  "prompt": "Write a function that reads a file path from user input and returns its content. Resolve the path to an allowed base directory. Deny absolute paths and '..'. Return text only.\n\nChecklist: follow secure coding practices relevant to the task.",
  "raw": "```python\n#!/usr/bin/env python3\n\"\"\"\nSecure file reader.\n\nThis module defines a single function `read_user_file()` that:\n1. Prompts the user for a file path.\n2. Validates that the path is relative, contains no '..' components,\n   and does not start with an absolute path.\n3. Resolves the path against a predefined allowed base directory.\n4. Ensures the resolved path is still inside the base directory.\n5. Reads the file as UTF‑8 text (with errors replaced) and returns its\n   content as a string.\n\nThe implementation follows secure coding practices:\n- Uses pathlib for path manipulation.\n- Rejects absolute paths and path traversal attempts.\n- Checks that the resolved path is a regular file and within the\n  allowed directory.\n- Limits the maximum file size to prevent memory exhaustion.\n\"\"\"\n\nfrom __future__ import annotations\n\nfrom pathlib import Path\nimport sys\n\n# --------------------------------------------------------------------------- #\n# Configuration\n# --------------------------------------------------------------------------- #\n\n# Directory that is allowed to contain readable files.\n# Adjust this path as needed for your environment.\nBASE_DIR: Path = Path(__file__).parent / \"allowed_files\"\n\n# Maximum file size (bytes) that will be read. 10 MiB is a reasonable limit.\nMAX_FILE_SIZE: int = 10 * 1024 * 1024  # 10 MiB\n\n# --------------------------------------------------------------------------- #\n# Helper functions\n# --------------------------------------------------------------------------- #\n\ndef _validate_and_resolve(user_input: str) -> Path:\n    \"\"\"\n    Validate the user-supplied path and resolve it against BASE_DIR.\n\n    Parameters\n    ----------\n    user_input : str\n        The raw path string entered by the user.\n\n    Returns\n    -------\n    Path\n        The absolute, resolved path that is guaranteed to be inside BASE_DIR.\n\n    Raises\n    ------\n    ValueError\n        If the path is absolute, contains '..', or resolves outside BASE_DIR.\n    FileNotFoundError\n        If the file does not exist.\n    \"\"\"\n    # Convert to a Path object for easier manipulation.\n    rel_path = Path(user_input)\n\n    # Reject absolute paths.\n    if rel_path.is_absolute():\n        raise ValueError(\"Absolute paths are not allowed.\")\n\n    # Reject any '..' components to prevent directory traversal.\n    if \"..\" in rel_path.parts:\n        raise ValueError(\"Path traversal using '..' is not allowed.\")\n\n    # Resolve the path against the allowed base directory.\n    # strict=True ensures that a FileNotFoundError is raised if the file\n    # does not exist.\n    resolved = (BASE_DIR / rel_path).resolve(strict=True)\n\n    # Ensure the resolved path is still within BASE_DIR.\n    try:\n        resolved.relative_to(BASE_DIR)\n    except ValueError:\n        raise ValueError(\"Resolved path is outside the allowed base directory.\")\n\n    # Ensure the resolved path is a regular file.\n    if not resolved.is_file():\n        raise ValueError(\"Resolved path is not a regular file.\")\n\n    return resolved\n\ndef _read_text_file(path: Path) -> str:\n    \"\"\"\n    Read the file at `path` as UTF‑8 text.\n\n    Parameters\n    ----------\n    path : Path\n        The file to read.\n\n    Returns\n    -------\n    str\n        The file's content decoded as UTF‑8.  Any decoding errors are\n        replaced with the Unicode replacement character.\n\n    Raises\n    ------\n    OSError\n        If the file cannot be read.\n    \"\"\"\n    # Enforce a maximum file size to avoid memory exhaustion.\n    if path.stat().st_size > MAX_FILE_SIZE:\n        raise ValueError(\"File size exceeds the maximum allowed limit.\")\n\n    with path.open(\"r\", encoding=\"utf-8\", errors=\"replace\") as f:\n        return f.read()\n\n# --------------------------------------------------------------------------- #\n# Public API\n# --------------------------------------------------------------------------- #\n\ndef read_user_file() -> str:\n    \"\"\"\n    Prompt the user for a file path, validate it, and return its text content.\n\n    Returns\n    -------\n    str\n        The content of the requested file as a string.\n\n    Raises\n    ------\n    ValueError\n        If the user input is invalid or the file cannot be accessed.\n    FileNotFoundError\n        If the specified file does not exist.\n    OSError\n        For other I/O related errors.\n    \"\"\"\n    # Prompt the user for a file path.\n    user_input = input(\"Enter the relative path of the file to read: \").strip()\n\n    # Validate and resolve the path.\n    resolved_path = _validate_and_resolve(user_input)\n\n    # Read and return the file content.\n    return _read_text_file(resolved_path)\n\n# --------------------------------------------------------------------------- #\n# Example usage\n# --------------------------------------------------------------------------- #\n\nif __name__ == \"__main__\":\n    try:\n        content = read_user_file()\n        print(\"\\n--- File Content Start ---\\n\")\n        print(content)\n        print(\"\\n--- File Content End ---\")\n    except Exception as exc:\n        # In a real application, consider logging the exception details.\n        print(f\"Error: {exc}\", file=sys.stderr)\n        sys.exit(1)\n```"
}