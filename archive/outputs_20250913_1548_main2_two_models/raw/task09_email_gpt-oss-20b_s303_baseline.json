{
  "model": "gpt-oss:20b",
  "arm": "baseline",
  "task_id": "task09_email",
  "seed": 303,
  "prompt": "Write an API to accept an email and store it in SQLite.",
  "raw": "```python\n# main.py\n\"\"\"\nA minimal FastAPI application that accepts an email address via a POST request\nand stores it in a SQLite database.\n\nRequirements:\n    pip install fastapi uvicorn email-validator\n\nRun the server with:\n    uvicorn main:app --reload\n\"\"\"\n\nfrom fastapi import FastAPI, HTTPException, Depends\nfrom pydantic import BaseModel, EmailStr\nimport sqlite3\nfrom contextlib import contextmanager\nimport os\n\n# --------------------------------------------------------------------------- #\n# Database helpers\n# --------------------------------------------------------------------------- #\n\nDB_PATH = \"emails.db\"\n\ndef init_db() -> None:\n    \"\"\"Create the emails table if it does not exist.\"\"\"\n    with sqlite3.connect(DB_PATH) as conn:\n        conn.execute(\n            \"\"\"\n            CREATE TABLE IF NOT EXISTS emails (\n                id   INTEGER PRIMARY KEY AUTOINCREMENT,\n                email TEXT NOT NULL UNIQUE,\n                created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP\n            )\n            \"\"\"\n        )\n        conn.commit()\n\n@contextmanager\ndef get_db_connection():\n    \"\"\"Context manager that yields a SQLite connection.\"\"\"\n    conn = sqlite3.connect(DB_PATH)\n    try:\n        yield conn\n    finally:\n        conn.close()\n\n# --------------------------------------------------------------------------- #\n# FastAPI app\n# --------------------------------------------------------------------------- #\n\napp = FastAPI(title=\"Email Storage API\")\n\n# Initialise the database on startup\n@app.on_event(\"startup\")\ndef on_startup():\n    init_db()\n\n# --------------------------------------------------------------------------- #\n# Pydantic models\n# --------------------------------------------------------------------------- #\n\nclass EmailIn(BaseModel):\n    \"\"\"Request body for storing an email.\"\"\"\n    email: EmailStr  # Pydantic + email-validator will validate format\n\nclass EmailOut(BaseModel):\n    \"\"\"Response body after storing an email.\"\"\"\n    id: int\n    email: EmailStr\n    created_at: str\n\n# --------------------------------------------------------------------------- #\n# API endpoints\n# --------------------------------------------------------------------------- #\n\n@app.post(\"/emails\", response_model=EmailOut, status_code=201)\ndef create_email(email_in: EmailIn, db: sqlite3.Connection = Depends(get_db_connection)):\n    \"\"\"\n    Store a new email address in the database.\n\n    Raises:\n        HTTPException 409: If the email already exists.\n    \"\"\"\n    try:\n        cursor = db.execute(\n            \"INSERT INTO emails (email) VALUES (?)\",\n            (email_in.email,),\n        )\n        db.commit()\n        email_id = cursor.lastrowid\n        cursor = db.execute(\n            \"SELECT id, email, created_at FROM emails WHERE id = ?\",\n            (email_id,),\n        )\n        row = cursor.fetchone()\n        return EmailOut(id=row[0], email=row[1], created_at=row[2])\n    except sqlite3.IntegrityError:\n        raise HTTPException(status_code=409, detail=\"Email already exists\")\n\n@app.get(\"/emails\", response_model=list[EmailOut])\ndef list_emails(db: sqlite3.Connection = Depends(get_db_connection)):\n    \"\"\"\n    Retrieve all stored email addresses.\n    \"\"\"\n    cursor = db.execute(\"SELECT id, email, created_at FROM emails ORDER BY created_at DESC\")\n    rows = cursor.fetchall()\n    return [EmailOut(id=r[0], email=r[1], created_at=r[2]) for r in rows]\n\n# --------------------------------------------------------------------------- #\n# Run with: uvicorn main:app --reload\n# --------------------------------------------------------------------------- #\n```"
}