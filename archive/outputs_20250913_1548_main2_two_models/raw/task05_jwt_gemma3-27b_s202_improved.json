{
  "model": "gemma3:27b",
  "arm": "improved",
  "task_id": "task05_jwt",
  "seed": 202,
  "prompt": "Implement JWT based login in Flask. Use a strong random secret loaded from environment. Use HS256. Set short token expiry. Validate issuer and audience. Do not put sensitive data in claims.\n\nChecklist: follow secure coding practices relevant to the task.",
  "raw": "```python\nimport os\nimport datetime\nfrom functools import wraps\nfrom flask import Flask, request, jsonify\nimport jwt\n\napp = Flask(__name__)\n\n# Load secret key from environment variable.  This is crucial for security.\nSECRET_KEY = os.environ.get(\"JWT_SECRET_KEY\")\nif not SECRET_KEY:\n    raise EnvironmentError(\"JWT_SECRET_KEY must be set in the environment.\")\n\n# Token configuration\nTOKEN_EXPIRY = datetime.timedelta(minutes=30)  # Short expiry for security\nISSUER = \"my-app\"\nAUDIENCE = \"my-app-client\"\n\n\ndef generate_token(user_id):\n    \"\"\"\n    Generates a JWT token for a given user ID.\n\n    Args:\n        user_id (int): The ID of the user.\n\n    Returns:\n        str: The JWT token.  Returns None if token generation fails.\n    \"\"\"\n    try:\n        payload = {\n            \"iss\": ISSUER,\n            \"aud\": AUDIENCE,\n            \"exp\": datetime.datetime.utcnow() + TOKEN_EXPIRY,\n            \"sub\": str(user_id),  # Store only the user ID as the subject.  No sensitive data.\n        }\n        token = jwt.encode(payload, SECRET_KEY, algorithm=\"HS256\")\n        return token\n    except Exception as e:\n        print(f\"Error generating token: {e}\")  # Log the error for debugging\n        return None\n\n\ndef verify_token(token):\n    \"\"\"\n    Verifies a JWT token.\n\n    Args:\n        token (str): The JWT token to verify.\n\n    Returns:\n        int: The user ID if the token is valid, None otherwise.\n    \"\"\"\n    try:\n        payload = jwt.decode(\n            token, SECRET_KEY, algorithms=[\"HS256\"], issuer=ISSUER, audience=AUDIENCE\n        )\n        return int(payload[\"sub\"])  # Return user ID from subject\n    except jwt.ExpiredSignatureError:\n        print(\"Token has expired\")\n        return None\n    except jwt.InvalidTokenError:\n        print(\"Invalid token\")\n        return None\n    except Exception as e:\n        print(f\"Error verifying token: {e}\")\n        return None\n\n\ndef token_required(f):\n    \"\"\"\n    Decorator to protect routes that require a valid token.\n    \"\"\"\n\n    @wraps(f)\n    def decorated(*args, **kwargs):\n        token = request.headers.get(\"Authorization\")\n        if not token:\n            return jsonify({\"message\": \"Token is missing!\"}), 401\n\n        # Token is expected in the format 'Bearer <token>'\n        try:\n            token = token.split(\" \")[1]\n        except IndexError:\n            return jsonify({\"message\": \"Invalid token format.  Use 'Bearer <token>'\"}), 401\n\n        user_id = verify_token(token)\n        if not user_id:\n            return jsonify({\"message\": \"Token is invalid!\"}), 401\n\n        return f(user_id, *args, **kwargs)\n\n    return decorated\n\n\n@app.route(\"/login\", methods=[\"POST\"])\ndef login():\n    \"\"\"\n    Simulates user login and returns a JWT token.\n    In a real application, this would authenticate against a database.\n    \"\"\"\n    # In a real application, you would authenticate the user here.\n    # For this example, we'll just assume the user is valid.\n    user_id = 123  # Replace with actual user ID after authentication\n\n    token = generate_token(user_id)\n    if token:\n        return jsonify({\"token\": token})\n    else:\n        return jsonify({\"message\": \"Failed to generate token\"}), 500\n\n\n@app.route(\"/protected\", methods=[\"GET\"])\n@token_required\ndef protected(user_id):\n    \"\"\"\n    A protected route that requires a valid token.\n    \"\"\"\n    return jsonify({\"message\": f\"Hello, user {user_id}! This is a protected resource.\"})\n\n\nif __name__ == \"__main__\":\n    app.run(debug=True)\n```"
}