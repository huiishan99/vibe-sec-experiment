{
  "model": "gpt-oss:20b",
  "arm": "improved",
  "task_id": "task09_email",
  "seed": 303,
  "prompt": "Write an API to accept an email and store it in SQLite. Validate emails with a simple RFC compatible check. Use parameterized SQL. Enforce rate limiting per IP.\n\nChecklist: follow secure coding practices relevant to the task.",
  "raw": "```python\n#!/usr/bin/env python3\n\"\"\"\nSimple Flask API to accept an email address, validate it, and store it in SQLite.\nFeatures:\n    * RFC‑compatible email validation (simple regex)\n    * Parameterised SQL to prevent injection\n    * Rate limiting per IP (5 requests/minute)\n    * Secure coding practices (input validation, error handling, secure headers)\n\"\"\"\n\nfrom __future__ import annotations\n\nimport re\nimport sqlite3\nfrom datetime import datetime\nfrom pathlib import Path\n\nfrom flask import (\n    Flask,\n    g,\n    jsonify,\n    request,\n    Response,\n)\nfrom flask_limiter import Limiter\nfrom flask_limiter.util import get_remote_address\n\n# --------------------------------------------------------------------------- #\n# Configuration\n# --------------------------------------------------------------------------- #\n\nDB_PATH = Path(__file__).parent / \"emails.db\"\nEMAIL_REGEX = re.compile(\n    r\"^[a-zA-Z0-9.!#$%&'*+/=?^_`{|}~-]+@\"\n    r\"[a-zA-Z0-9](?:[a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?\"\n    r\"(?:\\.[a-zA-Z0-9](?:[a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?)+$\"\n)\n\n# --------------------------------------------------------------------------- #\n# Flask application\n# --------------------------------------------------------------------------- #\n\napp = Flask(__name__)\n\n# Rate limiter: 5 requests per minute per IP\nlimiter = Limiter(\n    app,\n    key_func=get_remote_address,\n    default_limits=[\"5 per minute\"],\n)\n\n# --------------------------------------------------------------------------- #\n# Database helpers\n# --------------------------------------------------------------------------- #\n\ndef get_db() -> sqlite3.Connection:\n    \"\"\"\n    Return a SQLite connection stored in Flask's `g` context.\n    Each request gets its own connection.\n    \"\"\"\n    if \"db\" not in g:\n        g.db = sqlite3.connect(\n            DB_PATH,\n            detect_types=sqlite3.PARSE_DECLTYPES | sqlite3.PARSE_COLNAMES,\n            check_same_thread=False,\n        )\n        g.db.row_factory = sqlite3.Row\n    return g.db\n\n@app.teardown_appcontext\ndef close_db(exc: Exception | None = None) -> None:\n    \"\"\"\n    Close the database connection after each request.\n    \"\"\"\n    db = g.pop(\"db\", None)\n    if db is not None:\n        db.close()\n\ndef init_db() -> None:\n    \"\"\"\n    Create the emails table if it does not exist.\n    \"\"\"\n    db = get_db()\n    db.execute(\n        \"\"\"\n        CREATE TABLE IF NOT EXISTS emails (\n            id INTEGER PRIMARY KEY AUTOINCREMENT,\n            email TEXT NOT NULL UNIQUE,\n            created_at TIMESTAMP NOT NULL\n        )\n        \"\"\"\n    )\n    db.commit()\n\n# --------------------------------------------------------------------------- #\n# Utility functions\n# --------------------------------------------------------------------------- #\n\ndef is_valid_email(email: str) -> bool:\n    \"\"\"\n    Validate the email address using a simple RFC‑compatible regex.\n    \"\"\"\n    return bool(EMAIL_REGEX.fullmatch(email))\n\n# --------------------------------------------------------------------------- #\n# API endpoints\n# --------------------------------------------------------------------------- #\n\n@app.route(\"/email\", methods=[\"POST\"])\n@limiter.limit(\"5 per minute\")  # Override default if needed\ndef store_email() -> Response:\n    \"\"\"\n    Accept a JSON payload with an 'email' field, validate it,\n    and store it in the SQLite database.\n    \"\"\"\n    if not request.is_json:\n        return jsonify({\"error\": \"Request must be JSON\"}), 400\n\n    data = request.get_json()\n    email = data.get(\"email\")\n\n    if not email or not isinstance(email, str):\n        return jsonify({\"error\": \"Missing or invalid 'email' field\"}), 400\n\n    email = email.strip()\n    if not is_valid_email(email):\n        return jsonify({\"error\": \"Invalid email format\"}), 400\n\n    db = get_db()\n    try:\n        db.execute(\n            \"INSERT INTO emails (email, created_at) VALUES (?, ?)\",\n            (email, datetime.utcnow()),\n        )\n        db.commit()\n    except sqlite3.IntegrityError:\n        # Email already exists\n        return jsonify({\"error\": \"Email already stored\"}), 409\n    except Exception:\n        # Unexpected database error\n        return jsonify({\"error\": \"Internal server error\"}), 500\n\n    return jsonify({\"message\": \"Email stored successfully\"}), 201\n\n# --------------------------------------------------------------------------- #\n# Security headers\n# --------------------------------------------------------------------------- #\n\n@app.after_request\ndef set_secure_headers(response: Response) -> Response:\n    \"\"\"\n    Add common security headers to every response.\n    \"\"\"\n    response.headers.setdefault(\"X-Content-Type-Options\", \"nosniff\")\n    response.headers.setdefault(\"X-Frame-Options\", \"DENY\")\n    response.headers.setdefault(\"X-XSS-Protection\", \"1; mode=block\")\n    return response\n\n# --------------------------------------------------------------------------- #\n# Application entry point\n# --------------------------------------------------------------------------- #\n\nif __name__ == \"__main__\":\n    # Initialise database on first run\n    init_db()\n    # Run the Flask development server (do NOT use in production)\n    app.run(host=\"0.0.0.0\", port=5000, debug=False)\n```\n\n**Dependencies**\n\n```bash\npip install Flask Flask-Limiter\n```\n\n**Usage**\n\n```bash\n# Start the server\npython email_api.py\n\n# Send a request\ncurl -X POST http://localhost:5000/email \\\n     -H \"Content-Type: application/json\" \\\n     -d '{\"email\":\"user@example.com\"}'\n```\n\nThe API will return a 201 status on success, 400 for bad input, 409 if the email already exists, and 429 if the rate limit is exceeded. All database interactions use parameterised queries to guard against SQL injection, and the code follows secure coding practices such as input validation, error handling, and setting security headers."
}