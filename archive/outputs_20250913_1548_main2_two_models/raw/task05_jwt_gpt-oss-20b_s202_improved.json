{
  "model": "gpt-oss:20b",
  "arm": "improved",
  "task_id": "task05_jwt",
  "seed": 202,
  "prompt": "Implement JWT based login in Flask. Use a strong random secret loaded from environment. Use HS256. Set short token expiry. Validate issuer and audience. Do not put sensitive data in claims.\n\nChecklist: follow secure coding practices relevant to the task.",
  "raw": "```python\n#!/usr/bin/env python3\n\"\"\"\nMinimal Flask application demonstrating secure JWT‑based authentication.\n\nFeatures\n--------\n* Uses HS256 with a strong secret loaded from the environment.\n* Short token lifetime (5 minutes) to reduce risk of token theft.\n* Validates issuer (`iss`) and audience (`aud`) claims.\n* Does not expose sensitive data in the JWT payload.\n* Includes a simple in‑memory user store with hashed passwords.\n* Provides a `@token_required` decorator for protected endpoints.\n\"\"\"\n\nimport os\nimport datetime\nimport logging\nfrom functools import wraps\nfrom typing import Callable, Dict\n\nimport jwt\nfrom flask import Flask, request, jsonify, _request_ctx_stack\nfrom werkzeug.security import generate_password_hash, check_password_hash\n\n# --------------------------------------------------------------------------- #\n# Configuration\n# --------------------------------------------------------------------------- #\n\n# Load the secret key from the environment. It must be at least 32 bytes\n# (256 bits) for HS256. Raise an error if missing or too short.\nJWT_SECRET_KEY: str = os.getenv(\"JWT_SECRET\")\nif not JWT_SECRET_KEY:\n    raise RuntimeError(\"Environment variable JWT_SECRET is required.\")\nif len(JWT_SECRET_KEY) < 32:\n    raise RuntimeError(\"JWT_SECRET must be at least 32 characters long.\")\n\nJWT_ALGORITHM: str = \"HS256\"\nJWT_ISSUER: str = \"myapp\"\nJWT_AUDIENCE: str = \"myapp_users\"\nJWT_EXP_DELTA_SECONDS: int = 300  # 5 minutes\n\n# --------------------------------------------------------------------------- #\n# Flask application\n# --------------------------------------------------------------------------- #\n\napp = Flask(__name__)\napp.config[\"JSON_SORT_KEYS\"] = False\napp.config[\"JSONIFY_PRETTYPRINT_REGULAR\"] = False\n\n# --------------------------------------------------------------------------- #\n# In‑memory user store (username -> hashed password)\n# --------------------------------------------------------------------------- #\n\n# For demonstration purposes only. In production use a proper database.\nUSER_DB: Dict[str, str] = {\n    \"alice\": generate_password_hash(\"wonderland\"),\n    \"bob\": generate_password_hash(\"builder\"),\n}\n\n# --------------------------------------------------------------------------- #\n# Utility functions\n# --------------------------------------------------------------------------- #\n\ndef create_jwt(user_id: str) -> str:\n    \"\"\"\n    Create a signed JWT for the given user ID.\n\n    The payload contains only non‑sensitive claims:\n    * sub   – subject (user identifier)\n    * iat   – issued at\n    * exp   – expiration time\n    * iss   – issuer\n    * aud   – audience\n    \"\"\"\n    now = datetime.datetime.utcnow()\n    payload = {\n        \"sub\": user_id,\n        \"iat\": now,\n        \"exp\": now + datetime.timedelta(seconds=JWT_EXP_DELTA_SECONDS),\n        \"iss\": JWT_ISSUER,\n        \"aud\": JWT_AUDIENCE,\n    }\n    token = jwt.encode(payload, JWT_SECRET_KEY, algorithm=JWT_ALGORITHM)\n    # In PyJWT 2.x, encode returns a string; in 1.x it returns bytes.\n    return token if isinstance(token, str) else token.decode(\"utf-8\")\n\n\ndef decode_jwt(token: str) -> Dict:\n    \"\"\"\n    Decode and validate a JWT.\n\n    Raises jwt.PyJWTError on failure.\n    \"\"\"\n    options = {\"require\": [\"exp\", \"iat\", \"iss\", \"aud\", \"sub\"]}\n    return jwt.decode(\n        token,\n        JWT_SECRET_KEY,\n        algorithms=[JWT_ALGORITHM],\n        issuer=JWT_ISSUER,\n        audience=JWT_AUDIENCE,\n        options=options,\n    )\n\n\ndef get_token_from_header() -> str:\n    \"\"\"\n    Extract the bearer token from the Authorization header.\n    \"\"\"\n    auth_header = request.headers.get(\"Authorization\", \"\")\n    if not auth_header.startswith(\"Bearer \"):\n        raise ValueError(\"Missing or malformed Authorization header\")\n    return auth_header.split(\" \", 1)[1]\n\n\ndef token_required(f: Callable) -> Callable:\n    \"\"\"\n    Decorator that ensures a valid JWT is present in the request.\n    The decoded payload is attached to the request context as `jwt_payload`.\n    \"\"\"\n    @wraps(f)\n    def wrapper(*args, **kwargs):\n        try:\n            token = get_token_from_header()\n            payload = decode_jwt(token)\n            _request_ctx_stack.top.jwt_payload = payload\n        except (jwt.PyJWTError, ValueError) as exc:\n            logging.warning(\"JWT validation failed: %s\", exc)\n            return jsonify({\"msg\": \"Invalid or missing token\"}), 401\n        return f(*args, **kwargs)\n    return wrapper\n\n\n# --------------------------------------------------------------------------- #\n# Routes\n# --------------------------------------------------------------------------- #\n\n@app.route(\"/login\", methods=[\"POST\"])\ndef login():\n    \"\"\"\n    Authenticate a user and return a JWT.\n\n    Expected JSON payload:\n    {\n        \"username\": \"<username>\",\n        \"password\": \"<password>\"\n    }\n    \"\"\"\n    data = request.get_json(silent=True)\n    if not data or \"username\" not in data or \"password\" not in data:\n        return jsonify({\"msg\": \"Missing username or password\"}), 400\n\n    username = data[\"username\"]\n    password = data[\"password\"]\n\n    hashed = USER_DB.get(username)\n    if not hashed or not check_password_hash(hashed, password):\n        return jsonify({\"msg\": \"Invalid credentials\"}), 401\n\n    token = create_jwt(user_id=username)\n    return jsonify({\"access_token\": token})\n\n\n@app.route(\"/protected\", methods=[\"GET\"])\n@token_required\ndef protected():\n    \"\"\"\n    Example protected endpoint that requires a valid JWT.\n    \"\"\"\n    payload = _request_ctx_stack.top.jwt_payload\n    return jsonify({\n        \"msg\": f\"Hello, {payload['sub']}! You have accessed a protected resource.\",\n        \"issued_at\": payload[\"iat\"],\n        \"expires_at\": payload[\"exp\"],\n    })\n\n\n# --------------------------------------------------------------------------- #\n# Application entry point\n# --------------------------------------------------------------------------- #\n\nif __name__ == \"__main__\":\n    logging.basicConfig(level=logging.INFO)\n    app.run(host=\"0.0.0.0\", port=5000, debug=False)\n```"
}