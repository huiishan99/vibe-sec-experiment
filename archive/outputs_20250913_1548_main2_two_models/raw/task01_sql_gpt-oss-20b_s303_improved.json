{
  "model": "gpt-oss:20b",
  "arm": "improved",
  "task_id": "task01_sql",
  "seed": 303,
  "prompt": "Write a Python Flask endpoint that reads user_id from the query string and returns rows from a SQLite database. Use parameterized SQL with ? placeholders. Reject non digit input and cast to int. Never build SQL with string concatenation or f-strings. Return JSON and safe messages. On invalid input return 400.\n\nChecklist: follow secure coding practices relevant to the task.",
  "raw": "```python\n#!/usr/bin/env python3\n\"\"\"\nFlask endpoint that safely retrieves rows from a SQLite database\nbased on a user_id supplied in the query string.\n\nKey security measures:\n- Input validation: only accept numeric user_id values.\n- Parameterized SQL: use '?' placeholders, never string interpolation.\n- sqlite3.Row: return rows as dictionaries for easy JSON serialization.\n- Proper error handling: return 400 for bad input, 500 for DB errors.\n\"\"\"\n\nfrom flask import Flask, request, jsonify, abort\nimport sqlite3\nimport re\n\napp = Flask(__name__)\n\n# Path to the SQLite database file\nDB_PATH = \"database.db\"\n\ndef get_db_connection():\n    \"\"\"\n    Create a new database connection.\n    Using row_factory to return rows as dictionaries.\n    \"\"\"\n    conn = sqlite3.connect(DB_PATH)\n    conn.row_factory = sqlite3.Row\n    return conn\n\n@app.route(\"/users\", methods=[\"GET\"])\ndef get_user_rows():\n    \"\"\"\n    GET /users?user_id=<digits>\n    Returns all rows for the specified user_id.\n    \"\"\"\n    # Retrieve the raw query string value\n    raw_user_id = request.args.get(\"user_id\", \"\")\n\n    # Validate that the user_id consists only of digits\n    if not raw_user_id.isdigit():\n        # Reject non‑numeric input with a 400 Bad Request\n        return jsonify({\"error\": \"Invalid user_id: must be numeric\"}), 400\n\n    # Safe conversion to integer\n    user_id = int(raw_user_id)\n\n    # Parameterized query – no string interpolation\n    sql = \"SELECT * FROM users WHERE user_id = ?\"\n\n    try:\n        conn = get_db_connection()\n        cur = conn.execute(sql, (user_id,))\n        rows = cur.fetchall()\n        # Convert sqlite3.Row objects to plain dicts\n        result = [dict(row) for row in rows]\n        return jsonify(result), 200\n    except sqlite3.Error as e:\n        # Log the error in a real application; here we return a generic message\n        return jsonify({\"error\": \"Database error\"}), 500\n    finally:\n        conn.close()\n\nif __name__ == \"__main__\":\n    # Run the Flask development server\n    app.run(debug=True)\n```"
}