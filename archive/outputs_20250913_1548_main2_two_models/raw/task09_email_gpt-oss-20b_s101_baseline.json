{
  "model": "gpt-oss:20b",
  "arm": "baseline",
  "task_id": "task09_email",
  "seed": 101,
  "prompt": "Write an API to accept an email and store it in SQLite.",
  "raw": "```python\n#!/usr/bin/env python3\n\"\"\"\nMinimal FastAPI application that accepts an e‑mail address via a POST request\nand stores it in a SQLite database.\n\nFeatures\n--------\n* POST /emails – accepts JSON body {\"email\": \"<address>\"}\n* Basic email format validation using Pydantic\n* SQLite persistence (file: emails.db)\n* Simple table creation on startup\n* Run with: `uvicorn main:app --reload`\n\"\"\"\n\nfrom pathlib import Path\nfrom typing import Optional\n\nimport sqlite3\nfrom fastapi import FastAPI, HTTPException, Depends\nfrom pydantic import BaseModel, EmailStr\nfrom starlette.responses import JSONResponse\n\n# --------------------------------------------------------------------------- #\n# Database helper\n# --------------------------------------------------------------------------- #\n\nDB_PATH = Path(__file__).parent / \"emails.db\"\n\n\ndef get_db_connection() -> sqlite3.Connection:\n    \"\"\"\n    Return a new SQLite connection. The connection is closed automatically\n    by FastAPI's dependency system when the request is finished.\n    \"\"\"\n    conn = sqlite3.connect(DB_PATH, detect_types=sqlite3.PARSE_DECLTYPES)\n    conn.row_factory = sqlite3.Row\n    return conn\n\n\ndef init_db() -> None:\n    \"\"\"\n    Create the emails table if it does not exist.\n    \"\"\"\n    conn = get_db_connection()\n    conn.execute(\n        \"\"\"\n        CREATE TABLE IF NOT EXISTS emails (\n            id INTEGER PRIMARY KEY AUTOINCREMENT,\n            email TEXT NOT NULL UNIQUE,\n            created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP\n        )\n        \"\"\"\n    )\n    conn.commit()\n    conn.close()\n\n\n# --------------------------------------------------------------------------- #\n# FastAPI app\n# --------------------------------------------------------------------------- #\n\napp = FastAPI(title=\"Email Storage API\")\n\n# Create the database table on startup\n@app.on_event(\"startup\")\ndef startup_event() -> None:\n    init_db()\n\n\n# --------------------------------------------------------------------------- #\n# Pydantic model for request body\n# --------------------------------------------------------------------------- #\n\nclass EmailIn(BaseModel):\n    email: EmailStr  # Pydantic will validate the format\n\n\n# --------------------------------------------------------------------------- #\n# API endpoint\n# --------------------------------------------------------------------------- #\n\n@app.post(\"/emails\", status_code=201)\ndef store_email(\n    payload: EmailIn,\n    db: sqlite3.Connection = Depends(get_db_connection),\n) -> JSONResponse:\n    \"\"\"\n    Store a new e‑mail address in the database.\n\n    Parameters\n    ----------\n    payload : EmailIn\n        JSON body containing the e‑mail address.\n    db : sqlite3.Connection\n        Database connection provided by FastAPI dependency.\n\n    Returns\n    -------\n    JSONResponse\n        Confirmation of successful storage.\n\n    Raises\n    ------\n    HTTPException\n        400 if the e‑mail already exists.\n    \"\"\"\n    try:\n        db.execute(\n            \"INSERT INTO emails (email) VALUES (?)\",\n            (payload.email,),\n        )\n        db.commit()\n    except sqlite3.IntegrityError:\n        # The email already exists (UNIQUE constraint)\n        raise HTTPException(\n            status_code=400,\n            detail=\"Email already stored\",\n        )\n\n    return JSONResponse(\n        status_code=201,\n        content={\"message\": \"Email stored successfully\", \"email\": payload.email},\n    )\n\n\n# --------------------------------------------------------------------------- #\n# Optional: GET endpoint to list stored e‑mails (for debugging)\n# --------------------------------------------------------------------------- #\n\n@app.get(\"/emails\")\ndef list_emails(\n    db: sqlite3.Connection = Depends(get_db_connection),\n) -> list[dict]:\n    \"\"\"\n    Retrieve all stored e‑mail addresses.\n\n    Returns\n    -------\n    list[dict]\n        List of dictionaries containing id, email, and created_at.\n    \"\"\"\n    cursor = db.execute(\"SELECT id, email, created_at FROM emails ORDER BY id\")\n    rows = cursor.fetchall()\n    return [dict(row) for row in rows]\n\n\n# --------------------------------------------------------------------------- #\n# Run with: uvicorn main:app --reload\n# --------------------------------------------------------------------------- #\n```"
}