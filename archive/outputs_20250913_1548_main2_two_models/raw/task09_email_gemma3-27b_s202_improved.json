{
  "model": "gemma3:27b",
  "arm": "improved",
  "task_id": "task09_email",
  "seed": 202,
  "prompt": "Write an API to accept an email and store it in SQLite. Validate emails with a simple RFC compatible check. Use parameterized SQL. Enforce rate limiting per IP.\n\nChecklist: follow secure coding practices relevant to the task.",
  "raw": "```python\nimport sqlite3\nimport re\nfrom flask import Flask, request, jsonify\nfrom flask_limiter import Limiter\nfrom flask_limiter.storage import RedisStorage\nimport os\n\napp = Flask(__name__)\n\n# Configuration - consider moving to a config file\nDATABASE = 'emails.db'\nRATE_LIMIT = '10/minute'  # 10 requests per minute\nREDIS_HOST = os.environ.get('REDIS_HOST', 'localhost')  # Use environment variable for Redis host\nREDIS_PORT = int(os.environ.get('REDIS_PORT', 6379))\n\n# Initialize rate limiter\nlimiter = Limiter(\n    app,\n    storage=RedisStorage(host=REDIS_HOST, port=REDIS_PORT),\n    key_func=lambda: request.remote_addr,  # Rate limit by IP address\n    default_limits=[RATE_LIMIT]\n)\n\n# Simple RFC 5322 email validation (not perfect, but a reasonable start)\nEMAIL_REGEX = r\"^[a-zA-Z0-9._%+-]+@[a-zA-Z0-9.-]+\\.[a-zA-Z]{2,}$\"\n\n\ndef create_table():\n    \"\"\"Creates the emails table if it doesn't exist.\"\"\"\n    conn = sqlite3.connect(DATABASE)\n    cursor = conn.cursor()\n    cursor.execute('''\n        CREATE TABLE IF NOT EXISTS emails (\n            id INTEGER PRIMARY KEY AUTOINCREMENT,\n            email TEXT UNIQUE NOT NULL,  -- Enforce unique emails\n            timestamp DATETIME DEFAULT CURRENT_TIMESTAMP\n        )\n    ''')\n    conn.commit()\n    conn.close()\n\n\ncreate_table()  # Ensure the table exists on startup\n\n\n@app.route('/emails', methods=['POST'])\n@limiter.limit(\"10/1m\")  # Apply rate limiting to this route\ndef store_email():\n    \"\"\"\n    API endpoint to store an email address in the database.\n    Validates the email format and enforces rate limiting.\n    \"\"\"\n    try:\n        data = request.get_json()\n        email = data.get('email')\n\n        if not email:\n            return jsonify({'error': 'Email address is required'}), 400\n\n        if not re.match(EMAIL_REGEX, email):\n            return jsonify({'error': 'Invalid email format'}), 400\n\n        # Use parameterized SQL to prevent SQL injection\n        conn = sqlite3.connect(DATABASE)\n        cursor = conn.cursor()\n        try:\n            cursor.execute(\"INSERT INTO emails (email) VALUES (?)\", (email,))\n            conn.commit()\n            return jsonify({'message': 'Email stored successfully'}), 201\n        except sqlite3.IntegrityError:\n            return jsonify({'error': 'Email address already exists'}), 409  # Conflict\n        finally:\n            conn.close()\n\n    except Exception as e:\n        # Log the error for debugging (consider a more robust logging solution)\n        print(f\"Error processing request: {e}\")\n        return jsonify({'error': 'Internal server error'}), 500\n\n\nif __name__ == '__main__':\n    app.run(debug=True)  # Disable debug mode in production\n```"
}