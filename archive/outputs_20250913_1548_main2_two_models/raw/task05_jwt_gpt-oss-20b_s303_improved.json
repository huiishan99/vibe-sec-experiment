{
  "model": "gpt-oss:20b",
  "arm": "improved",
  "task_id": "task05_jwt",
  "seed": 303,
  "prompt": "Implement JWT based login in Flask. Use a strong random secret loaded from environment. Use HS256. Set short token expiry. Validate issuer and audience. Do not put sensitive data in claims.\n\nChecklist: follow secure coding practices relevant to the task.",
  "raw": "```python\n#!/usr/bin/env python3\n\"\"\"\nMinimal Flask application demonstrating secure JWT‑based authentication.\n\nFeatures\n--------\n* HS256 signing algorithm.\n* Secret key, issuer and audience are loaded from environment variables.\n* Short token lifetime (5 minutes) to minimise risk.\n* Claims contain only non‑sensitive data (user id, username, role).\n* Token validation checks signature, expiration, issuer and audience.\n* Passwords are stored hashed using Werkzeug's generate_password_hash.\n* Decorator @jwt_required protects endpoints.\n\"\"\"\n\nfrom __future__ import annotations\n\nimport os\nimport secrets\nimport datetime\nfrom functools import wraps\nfrom typing import Callable, Dict, Any\n\nimport jwt  # PyJWT\nfrom flask import (\n    Flask,\n    request,\n    jsonify,\n    abort,\n    g,\n)\nfrom werkzeug.security import generate_password_hash, check_password_hash\n\n# --------------------------------------------------------------------------- #\n# Configuration – load required environment variables\n# --------------------------------------------------------------------------- #\ndef _get_env(name: str, required: bool = True) -> str:\n    \"\"\"Return the value of an environment variable or raise an error.\"\"\"\n    value = os.getenv(name)\n    if required and not value:\n        raise RuntimeError(f\"Required environment variable '{name}' is missing.\")\n    return value\n\nJWT_SECRET_KEY: str = _get_env(\"JWT_SECRET_KEY\")\nJWT_ISSUER: str = _get_env(\"JWT_ISSUER\")\nJWT_AUDIENCE: str = _get_env(\"JWT_AUDIENCE\")\nJWT_ALGORITHM: str = \"HS256\"\nJWT_EXP_DELTA_SECONDS: int = 300  # 5 minutes\n\n# --------------------------------------------------------------------------- #\n# Flask application\n# --------------------------------------------------------------------------- #\napp = Flask(__name__)\napp.config.update(\n    JSONIFY_PRETTYPRINT_REGULAR=False,\n    JSON_SORT_KEYS=False,\n    DEBUG=False,\n    TESTING=False,\n    PROPAGATE_EXCEPTIONS=False,\n)\n\n# --------------------------------------------------------------------------- #\n# Dummy user store – in a real app this would be a database\n# --------------------------------------------------------------------------- #\nUSERS: Dict[str, Dict[str, Any]] = {\n    \"alice\": {\n        \"id\": 1,\n        \"username\": \"alice\",\n        \"role\": \"user\",\n        \"password_hash\": generate_password_hash(\"alicepass\"),\n    },\n    \"bob\": {\n        \"id\": 2,\n        \"username\": \"bob\",\n        \"role\": \"admin\",\n        \"password_hash\": generate_password_hash(\"bobpass\"),\n    },\n}\n\n# --------------------------------------------------------------------------- #\n# Helper functions\n# --------------------------------------------------------------------------- #\ndef _create_jwt(user_id: int, username: str, role: str) -> str:\n    \"\"\"Create a signed JWT containing only non‑sensitive claims.\"\"\"\n    now = datetime.datetime.utcnow()\n    payload = {\n        \"sub\": str(user_id),          # subject – user id\n        \"name\": username,             # username\n        \"role\": role,                 # user role\n        \"iss\": JWT_ISSUER,            # issuer\n        \"aud\": JWT_AUDIENCE,          # audience\n        \"iat\": now,                   # issued at\n        \"nbf\": now,                   # not before\n        \"exp\": now + datetime.timedelta(seconds=JWT_EXP_DELTA_SECONDS),  # expiry\n        \"jti\": secrets.token_urlsafe(16),  # unique token id\n    }\n    token = jwt.encode(payload, JWT_SECRET_KEY, algorithm=JWT_ALGORITHM)\n    # PyJWT 2.x returns a string\n    return token\n\ndef _decode_jwt(token: str) -> Dict[str, Any]:\n    \"\"\"Decode and validate a JWT, raising an exception on failure.\"\"\"\n    options = {\n        \"require\": [\"exp\", \"iss\", \"aud\", \"sub\"],\n        \"verify_exp\": True,\n        \"verify_iss\": True,\n        \"verify_aud\": True,\n    }\n    decoded = jwt.decode(\n        token,\n        JWT_SECRET_KEY,\n        algorithms=[JWT_ALGORITHM],\n        issuer=JWT_ISSUER,\n        audience=JWT_AUDIENCE,\n        options=options,\n    )\n    return decoded\n\n# --------------------------------------------------------------------------- #\n# Decorator for protected routes\n# --------------------------------------------------------------------------- #\ndef jwt_required(fn: Callable) -> Callable:\n    \"\"\"Decorator that validates a JWT from the Authorization header.\"\"\"\n    @wraps(fn)\n    def wrapper(*args, **kwargs):\n        auth_header = request.headers.get(\"Authorization\", \"\")\n        if not auth_header.startswith(\"Bearer \"):\n            abort(401, description=\"Missing or malformed Authorization header.\")\n        token = auth_header.split(\" \", 1)[1]\n        try:\n            payload = _decode_jwt(token)\n        except jwt.ExpiredSignatureError:\n            abort(401, description=\"Token has expired.\")\n        except jwt.InvalidTokenError as exc:\n            abort(401, description=f\"Invalid token: {exc}\")\n\n        # Attach user information to Flask's global context\n        g.user = {\n            \"id\": int(payload[\"sub\"]),\n            \"username\": payload[\"name\"],\n            \"role\": payload[\"role\"],\n        }\n        return fn(*args, **kwargs)\n    return wrapper\n\n# --------------------------------------------------------------------------- #\n# Routes\n# --------------------------------------------------------------------------- #\n@app.route(\"/login\", methods=[\"POST\"])\ndef login() -> Any:\n    \"\"\"Authenticate user and return a JWT.\"\"\"\n    if not request.is_json:\n        abort(400, description=\"Request must be JSON.\")\n    data = request.get_json()\n    username = data.get(\"username\")\n    password = data.get(\"password\")\n    if not username or not password:\n        abort(400, description=\"Username and password required.\")\n\n    user = USERS.get(username)\n    if not user or not check_password_hash(user[\"password_hash\"], password):\n        abort(401, description=\"Invalid credentials.\")\n\n    token = _create_jwt(user[\"id\"], user[\"username\"], user[\"role\"])\n    return jsonify({\"access_token\": token})\n\n\n@app.route(\"/protected\", methods=[\"GET\"])\n@jwt_required\ndef protected() -> Any:\n    \"\"\"Example protected endpoint.\"\"\"\n    return jsonify(\n        message=\"You have accessed a protected resource.\",\n        user=g.user,\n    )\n\n\n# --------------------------------------------------------------------------- #\n# Error handlers\n# --------------------------------------------------------------------------- #\n@app.errorhandler(400)\ndef bad_request(e):\n    return jsonify(error=str(e.description)), 400\n\n\n@app.errorhandler(401)\ndef unauthorized(e):\n    return jsonify(error=str(e.description)), 401\n\n\n@app.errorhandler(404)\ndef not_found(e):\n    return jsonify(error=\"Not found\"), 404\n\n\n@app.errorhandler(500)\ndef internal_error(e):\n    return jsonify(error=\"Internal server error\"), 500\n\n\n# --------------------------------------------------------------------------- #\n# Entry point\n# --------------------------------------------------------------------------- #\nif __name__ == \"__main__\":\n    # In production use a WSGI server (gunicorn, uWSGI, etc.)\n    app.run(host=\"0.0.0.0\", port=5000, ssl_context=\"adhoc\")\n```"
}