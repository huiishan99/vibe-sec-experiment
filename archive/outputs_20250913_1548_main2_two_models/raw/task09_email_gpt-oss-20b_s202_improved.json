{
  "model": "gpt-oss:20b",
  "arm": "improved",
  "task_id": "task09_email",
  "seed": 202,
  "prompt": "Write an API to accept an email and store it in SQLite. Validate emails with a simple RFC compatible check. Use parameterized SQL. Enforce rate limiting per IP.\n\nChecklist: follow secure coding practices relevant to the task.",
  "raw": "```python\n#!/usr/bin/env python3\n\"\"\"\nMinimal Flask API to accept an email address, validate it, and store it in SQLite.\nFeatures:\n    * RFC‑compatible email validation (simple regex)\n    * Parameterised SQL to prevent injection\n    * Per‑IP rate limiting (default: 5 requests per minute)\n    * Secure coding practices (input validation, error handling, unique constraint)\n\"\"\"\n\nfrom __future__ import annotations\n\nimport re\nimport sqlite3\nimport threading\nimport time\nfrom datetime import datetime, timedelta\nfrom pathlib import Path\nfrom typing import Dict, List\n\nfrom flask import Flask, jsonify, request, g\n\n# --------------------------------------------------------------------------- #\n# Configuration\n# --------------------------------------------------------------------------- #\n\n# SQLite database file (created in the same directory as this script)\nDB_PATH = Path(__file__).parent / \"emails.db\"\n\n# Rate‑limiting configuration\nRATE_LIMIT = 5          # max requests\nRATE_PERIOD = 60        # per seconds\n\n# Email validation regex (RFC‑5322 compliant for most common cases)\nEMAIL_REGEX = re.compile(\n    r\"(^[a-zA-Z0-9.!#$%&'*+/=?^_`{|}~-]+\"\n    r\"@[a-zA-Z0-9-]+(?:\\.[a-zA-Z0-9-]+)*$)\"\n)\n\n# --------------------------------------------------------------------------- #\n# Helper classes\n# --------------------------------------------------------------------------- #\n\nclass RateLimiter:\n    \"\"\"\n    Simple in‑memory rate limiter keyed by client IP.\n    Stores timestamps of recent requests and enforces a limit per period.\n    \"\"\"\n    def __init__(self, limit: int, period: int) -> None:\n        self.limit = limit\n        self.period = period\n        self.requests: Dict[str, List[float]] = {}\n        self.lock = threading.Lock()\n\n    def is_allowed(self, ip: str) -> bool:\n        \"\"\"Return True if the IP is allowed to make a request.\"\"\"\n        now = time.time()\n        window_start = now - self.period\n\n        with self.lock:\n            timestamps = self.requests.get(ip, [])\n\n            # Remove timestamps outside the window\n            timestamps = [ts for ts in timestamps if ts > window_start]\n            if len(timestamps) >= self.limit:\n                # Too many requests\n                self.requests[ip] = timestamps\n                return False\n\n            # Record this request\n            timestamps.append(now)\n            self.requests[ip] = timestamps\n            return True\n\n# --------------------------------------------------------------------------- #\n# Flask application\n# --------------------------------------------------------------------------- #\n\napp = Flask(__name__)\nrate_limiter = RateLimiter(RATE_LIMIT, RATE_PERIOD)\n\n# --------------------------------------------------------------------------- #\n# Database helpers\n# --------------------------------------------------------------------------- #\n\ndef get_db() -> sqlite3.Connection:\n    \"\"\"\n    Return a SQLite connection for the current request context.\n    The connection is stored in Flask's `g` object to be reused.\n    \"\"\"\n    if \"db\" not in g:\n        g.db = sqlite3.connect(\n            DB_PATH,\n            detect_types=sqlite3.PARSE_DECLTYPES | sqlite3.PARSE_COLNAMES,\n            isolation_level=None,  # autocommit mode\n        )\n        g.db.execute(\"PRAGMA foreign_keys = ON\")\n    return g.db\n\n@app.teardown_appcontext\ndef close_db(exc: Exception | None = None) -> None:\n    \"\"\"Close the database connection at the end of the request.\"\"\"\n    db = g.pop(\"db\", None)\n    if db is not None:\n        db.close()\n\ndef init_db() -> None:\n    \"\"\"Create the emails table if it does not exist.\"\"\"\n    db = get_db()\n    db.execute(\n        \"\"\"\n        CREATE TABLE IF NOT EXISTS emails (\n            id INTEGER PRIMARY KEY AUTOINCREMENT,\n            email TEXT NOT NULL UNIQUE,\n            created_at TIMESTAMP NOT NULL DEFAULT CURRENT_TIMESTAMP\n        )\n        \"\"\"\n    )\n\n# --------------------------------------------------------------------------- #\n# Utility functions\n# --------------------------------------------------------------------------- #\n\ndef is_valid_email(email: str) -> bool:\n    \"\"\"Return True if the email matches the RFC‑compatible regex.\"\"\"\n    return bool(EMAIL_REGEX.match(email))\n\n# --------------------------------------------------------------------------- #\n# API endpoint\n# --------------------------------------------------------------------------- #\n\n@app.route(\"/submit\", methods=[\"POST\"])\ndef submit_email() -> tuple[dict, int]:\n    \"\"\"\n    Accept a JSON payload with an 'email' field, validate it,\n    enforce rate limiting, and store it in the database.\n    \"\"\"\n    client_ip = request.remote_addr or \"unknown\"\n\n    # Rate limiting\n    if not rate_limiter.is_allowed(client_ip):\n        return jsonify({\"error\": \"Too many requests\"}), 429\n\n    # Parse JSON body\n    if not request.is_json:\n        return jsonify({\"error\": \"Request must be JSON\"}), 400\n\n    data = request.get_json()\n    email = data.get(\"email\")\n    if not email or not isinstance(email, str):\n        return jsonify({\"error\": \"Missing or invalid 'email' field\"}), 400\n\n    email = email.strip()\n    if not is_valid_email(email):\n        return jsonify({\"error\": \"Invalid email format\"}), 400\n\n    # Store in database\n    db = get_db()\n    try:\n        db.execute(\"INSERT INTO emails (email) VALUES (?)\", (email,))\n    except sqlite3.IntegrityError:\n        # Email already exists\n        return jsonify({\"message\": \"Email already stored\"}), 200\n    except Exception as exc:\n        # Unexpected database error\n        app.logger.exception(\"Database error while inserting email\")\n        return jsonify({\"error\": \"Internal server error\"}), 500\n\n    return jsonify({\"message\": \"Email stored successfully\"}), 201\n\n# --------------------------------------------------------------------------- #\n# Application entry point\n# --------------------------------------------------------------------------- #\n\nif __name__ == \"__main__\":\n    # Ensure the database is initialized before starting the server\n    init_db()\n    # Run the Flask development server (not for production)\n    app.run(host=\"0.0.0.0\", port=5000, debug=False)\n```"
}