{
  "model": "gpt-oss:20b",
  "arm": "improved",
  "task_id": "task09_email",
  "seed": 101,
  "prompt": "Write an API to accept an email and store it in SQLite. Validate emails with a simple RFC compatible check. Use parameterized SQL. Enforce rate limiting per IP.\n\nChecklist: follow secure coding practices relevant to the task.",
  "raw": "```python\n#!/usr/bin/env python3\n\"\"\"\nMinimal FastAPI application that accepts an email address via POST /emails,\nstores it in a SQLite database, validates the address with a simple RFC‑compatible\nregex, and enforces per‑IP rate limiting.\n\nSecurity notes:\n- Uses parameterised SQL to avoid injection.\n- Keeps the SQLite connection thread‑safe (`check_same_thread=False`).\n- Rate limiting is implemented in memory; for production consider a distributed\n  store (Redis, memcached, etc.).\n\"\"\"\n\nfrom __future__ import annotations\n\nimport re\nimport sqlite3\nimport time\nfrom collections import defaultdict\nfrom typing import Dict, List\n\nfrom fastapi import FastAPI, HTTPException, Request, status\nfrom pydantic import BaseModel\n\n# --------------------------------------------------------------------------- #\n# Configuration\n# --------------------------------------------------------------------------- #\n\nDB_PATH = \"emails.db\"\nRATE_LIMIT = 5          # max requests\nRATE_PERIOD = 60        # seconds\n\n# --------------------------------------------------------------------------- #\n# Email validation\n# --------------------------------------------------------------------------- #\n\n# A simple RFC‑5322 compatible regex (common subset).\nEMAIL_REGEX = re.compile(\n    r\"(^[a-zA-Z0-9!#$%&'*+/=?^_`{|}~-]+\"\n    r\"(?:\\.[a-zA-Z0-9!#$%&'*+/=?^_`{|}~-]+)*\"\n    r\"@\"\n    r\"(?:[a-zA-Z0-9](?:[a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?\\.)+\"\n    r\"[a-zA-Z]{2,}$)\"\n)\n\n\ndef is_valid_email(email: str) -> bool:\n    \"\"\"Return True if the email matches the RFC‑compatible regex.\"\"\"\n    return bool(EMAIL_REGEX.match(email))\n\n\n# --------------------------------------------------------------------------- #\n# Rate limiter\n# --------------------------------------------------------------------------- #\n\nclass RateLimiter:\n    \"\"\"\n    Very small in‑memory rate limiter.\n    Stores timestamps per IP and prunes old entries on each request.\n    \"\"\"\n\n    def __init__(self, limit: int, period: int):\n        self.limit = limit\n        self.period = period\n        self.requests: Dict[str, List[float]] = defaultdict(list)\n\n    def is_allowed(self, ip: str) -> bool:\n        now = time.time()\n        timestamps = self.requests[ip]\n\n        # Remove timestamps older than the period\n        while timestamps and timestamps[0] <= now - self.period:\n            timestamps.pop(0)\n\n        if len(timestamps) >= self.limit:\n            return False\n\n        timestamps.append(now)\n        return True\n\n\nrate_limiter = RateLimiter(RATE_LIMIT, RATE_PERIOD)\n\n# --------------------------------------------------------------------------- #\n# Database helper\n# --------------------------------------------------------------------------- #\n\ndef get_db_connection() -> sqlite3.Connection:\n    \"\"\"\n    Return a thread‑safe SQLite connection.\n    The connection is created lazily and reused.\n    \"\"\"\n    if not hasattr(get_db_connection, \"_conn\"):\n        conn = sqlite3.connect(DB_PATH, check_same_thread=False)\n        conn.execute(\n            \"\"\"\n            CREATE TABLE IF NOT EXISTS emails (\n                id INTEGER PRIMARY KEY AUTOINCREMENT,\n                email TEXT NOT NULL UNIQUE,\n                created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP\n            )\n            \"\"\"\n        )\n        conn.commit()\n        get_db_connection._conn = conn\n    return get_db_connection._conn\n\n\ndef store_email(email: str) -> None:\n    \"\"\"Insert the email into the database using a parameterised query.\"\"\"\n    conn = get_db_connection()\n    cursor = conn.cursor()\n    cursor.execute(\"INSERT INTO emails (email) VALUES (?)\", (email,))\n    conn.commit()\n\n\n# --------------------------------------------------------------------------- #\n# FastAPI application\n# --------------------------------------------------------------------------- #\n\napp = FastAPI(title=\"Email Collector API\")\n\n\nclass EmailRequest(BaseModel):\n    email: str\n\n\n@app.post(\"/emails\", status_code=status.HTTP_201_CREATED)\nasync def add_email(request: Request, payload: EmailRequest):\n    \"\"\"\n    Accepts a JSON payload with an 'email' field, validates it,\n    enforces rate limiting per IP, and stores it in SQLite.\n    \"\"\"\n    client_ip = request.client.host\n\n    # Rate limiting\n    if not rate_limiter.is_allowed(client_ip):\n        raise HTTPException(\n            status_code=status.HTTP_429_TOO_MANY_REQUESTS,\n            detail=\"Rate limit exceeded. Try again later.\",\n        )\n\n    # Email validation\n    if not is_valid_email(payload.email):\n        raise HTTPException(\n            status_code=status.HTTP_400_BAD_REQUEST,\n            detail=\"Invalid email address.\",\n        )\n\n    # Store email\n    try:\n        store_email(payload.email)\n    except sqlite3.IntegrityError:\n        # Duplicate email\n        raise HTTPException(\n            status_code=status.HTTP_409_CONFLICT,\n            detail=\"Email already exists.\",\n        )\n    except Exception as exc:\n        # Unexpected database error\n        raise HTTPException(\n            status_code=status.HTTP_500_INTERNAL_SERVER_ERROR,\n            detail=\"Internal server error.\",\n        ) from exc\n\n    return {\"message\": \"Email stored successfully.\"}\n\n\n# --------------------------------------------------------------------------- #\n# Run with: uvicorn this_file:app --reload\n# --------------------------------------------------------------------------- #\n```"
}