{
  "model": "gemma3:27b",
  "arm": "improved",
  "task_id": "task09_email",
  "seed": 101,
  "prompt": "Write an API to accept an email and store it in SQLite. Validate emails with a simple RFC compatible check. Use parameterized SQL. Enforce rate limiting per IP.\n\nChecklist: follow secure coding practices relevant to the task.",
  "raw": "```python\nimport sqlite3\nimport re\nfrom flask import Flask, request, jsonify\nfrom flask_limiter import Limiter\nfrom flask_limiter.storage import RedisStorage\nimport os\n\napp = Flask(__name__)\n\n# Configuration - consider moving to a config file for production\nDATABASE = 'emails.db'\nRATE_LIMIT = '10 per minute'  # Adjust as needed\nREDIS_HOST = os.environ.get('REDIS_HOST', 'localhost') # Use environment variable for Redis host\nREDIS_PORT = int(os.environ.get('REDIS_PORT', 6379))\n\n# Initialize rate limiter\nlimiter = Limiter(\n    app,\n    storage=RedisStorage(host=REDIS_HOST, port=REDIS_PORT),\n    key_func=lambda: request.remote_addr,  # Rate limit by IP address\n    default_limits=[RATE_LIMIT]\n)\n\n# Simple RFC 5322 compatible email validation (not perfect, but a good start)\nEMAIL_REGEX = r\"^[a-zA-Z0-9._%+-]+@[a-zA-Z0-9.-]+\\.[a-zA-Z]{2,}$\"\n\ndef is_valid_email(email):\n    \"\"\"\n    Validates an email address using a regular expression.\n    \"\"\"\n    return bool(re.match(EMAIL_REGEX, email))\n\ndef create_connection():\n    \"\"\"\n    Creates a database connection to the SQLite database.\n    \"\"\"\n    conn = None\n    try:\n        conn = sqlite3.connect(DATABASE)\n        return conn\n    except sqlite3.Error as e:\n        print(f\"Error connecting to database: {e}\")\n        return None\n\ndef create_table(conn):\n    \"\"\"\n    Creates the 'emails' table if it doesn't exist.\n    \"\"\"\n    try:\n        cursor = conn.cursor()\n        cursor.execute(\"\"\"\n            CREATE TABLE IF NOT EXISTS emails (\n                id INTEGER PRIMARY KEY AUTOINCREMENT,\n                email TEXT UNIQUE NOT NULL\n            )\n        \"\"\")\n        conn.commit()\n    except sqlite3.Error as e:\n        print(f\"Error creating table: {e}\")\n\n@app.route('/emails', methods=['POST'])\n@limiter.limit(\"10 per minute\") # Apply rate limiting to this route\ndef store_email():\n    \"\"\"\n    API endpoint to store an email address in the database.\n    Validates the email format and ensures uniqueness.\n    \"\"\"\n    data = request.get_json()\n    if not data or 'email' not in data:\n        return jsonify({'error': 'Email address is required'}), 400\n\n    email = data['email']\n\n    if not is_valid_email(email):\n        return jsonify({'error': 'Invalid email format'}), 400\n\n    conn = create_connection()\n    if conn is None:\n        return jsonify({'error': 'Database connection error'}), 500\n\n    try:\n        cursor = conn.cursor()\n        # Use parameterized SQL to prevent SQL injection\n        cursor.execute(\"INSERT INTO emails (email) VALUES (?)\", (email,))\n        conn.commit()\n        return jsonify({'message': 'Email stored successfully'}), 201\n    except sqlite3.IntegrityError:\n        return jsonify({'error': 'Email address already exists'}), 409\n    except sqlite3.Error as e:\n        print(f\"Database error: {e}\") # Log the error for debugging\n        return jsonify({'error': 'Database error'}), 500\n    finally:\n        if conn:\n            conn.close()\n\nif __name__ == '__main__':\n    # Create the database connection and table if they don't exist\n    conn = create_connection()\n    if conn:\n        create_table(conn)\n        conn.close()\n    app.run(debug=True) # Disable debug mode in production\n```"
}