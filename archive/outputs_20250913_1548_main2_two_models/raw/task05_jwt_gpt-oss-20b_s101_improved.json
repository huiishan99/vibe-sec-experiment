{
  "model": "gpt-oss:20b",
  "arm": "improved",
  "task_id": "task05_jwt",
  "seed": 101,
  "prompt": "Implement JWT based login in Flask. Use a strong random secret loaded from environment. Use HS256. Set short token expiry. Validate issuer and audience. Do not put sensitive data in claims.\n\nChecklist: follow secure coding practices relevant to the task.",
  "raw": "```python\n#!/usr/bin/env python3\n\"\"\"\nMinimal Flask application demonstrating JWT‑based authentication.\n\nFeatures\n--------\n* Uses a strong, random secret key loaded from the environment.\n* Generates short‑lived (5‑minute) HS256 tokens.\n* Includes issuer (`iss`) and audience (`aud`) claims and validates them.\n* Does **not** store sensitive data (e.g. passwords) in the token payload.\n* Provides a protected endpoint that requires a valid JWT.\n\nSecurity notes\n--------------\n* The secret key must be at least 256 bits (32 bytes).  In production\n  generate it with `openssl rand -base64 32` and set it in the\n  environment variable `JWT_SECRET`.\n* The issuer and audience values should be set to known, trusted\n  strings (e.g. your domain) and validated on every request.\n* Tokens are signed with HS256; the key is kept secret on the server.\n* The token is transmitted via the `Authorization: Bearer <token>`\n  header – never in query strings or cookies unless you set the\n  appropriate flags.\n\"\"\"\n\nimport os\nimport datetime\nfrom functools import wraps\n\nfrom flask import Flask, request, jsonify, abort\nimport jwt  # PyJWT\n\n# --------------------------------------------------------------------------- #\n# Configuration – read from environment\n# --------------------------------------------------------------------------- #\nJWT_SECRET = os.getenv(\"JWT_SECRET\")\nJWT_ISSUER = os.getenv(\"JWT_ISSUER\")\nJWT_AUDIENCE = os.getenv(\"JWT_AUDIENCE\")\n\n# Ensure required configuration is present\nif not all([JWT_SECRET, JWT_ISSUER, JWT_AUDIENCE]):\n    raise RuntimeError(\n        \"Missing required environment variables: \"\n        \"JWT_SECRET, JWT_ISSUER, JWT_AUDIENCE\"\n    )\n\n# Token lifetime – 5 minutes\nTOKEN_EXPIRY_SECONDS = 5 * 60\n\n# --------------------------------------------------------------------------- #\n# Flask application\n# --------------------------------------------------------------------------- #\napp = Flask(__name__)\n\n# --------------------------------------------------------------------------- #\n# Dummy user store – in a real app use a database and hashed passwords\n# --------------------------------------------------------------------------- #\nUSERS = {\n    \"alice\": {\"id\": 1, \"password\": \"wonderland\"},\n    \"bob\": {\"id\": 2, \"password\": \"builder\"},\n}\n\n# --------------------------------------------------------------------------- #\n# Helper functions\n# --------------------------------------------------------------------------- #\ndef create_jwt(user_id: int) -> str:\n    \"\"\"\n    Create a signed JWT for the given user ID.\n\n    The payload contains only non‑sensitive claims:\n    * sub – subject (user ID)\n    * iss – issuer\n    * aud – audience\n    * exp – expiration time\n    \"\"\"\n    now = datetime.datetime.utcnow()\n    payload = {\n        \"sub\": str(user_id),\n        \"iss\": JWT_ISSUER,\n        \"aud\": JWT_AUDIENCE,\n        \"iat\": now,\n        \"exp\": now + datetime.timedelta(seconds=TOKEN_EXPIRY_SECONDS),\n    }\n    token = jwt.encode(payload, JWT_SECRET, algorithm=\"HS256\")\n    # PyJWT 2.x returns a string; 1.x returns bytes\n    return token if isinstance(token, str) else token.decode(\"utf-8\")\n\n\ndef verify_jwt(token: str) -> dict:\n    \"\"\"\n    Verify the JWT and return its payload.\n\n    Raises `jwt.InvalidTokenError` if verification fails.\n    \"\"\"\n    return jwt.decode(\n        token,\n        JWT_SECRET,\n        algorithms=[\"HS256\"],\n        issuer=JWT_ISSUER,\n        audience=JWT_AUDIENCE,\n    )\n\n\ndef jwt_required(fn):\n    \"\"\"\n    Decorator that enforces a valid JWT in the `Authorization` header.\n    The decoded payload is passed to the wrapped function as `payload`.\n    \"\"\"\n    @wraps(fn)\n    def wrapper(*args, **kwargs):\n        auth_header = request.headers.get(\"Authorization\", \"\")\n        if not auth_header.startswith(\"Bearer \"):\n            abort(401, description=\"Missing or malformed Authorization header\")\n        token = auth_header.split(\" \", 1)[1]\n        try:\n            payload = verify_jwt(token)\n        except jwt.PyJWTError as exc:\n            abort(401, description=f\"Invalid token: {exc}\")\n        # Pass the payload to the view\n        return fn(payload=payload, *args, **kwargs)\n    return wrapper\n\n# --------------------------------------------------------------------------- #\n# Routes\n# --------------------------------------------------------------------------- #\n@app.route(\"/login\", methods=[\"POST\"])\ndef login():\n    \"\"\"\n    Authenticate a user and return a JWT.\n\n    Expected JSON body:\n        { \"username\": \"...\", \"password\": \"...\" }\n    \"\"\"\n    data = request.get_json()\n    if not data:\n        abort(400, description=\"Missing JSON body\")\n\n    username = data.get(\"username\")\n    password = data.get(\"password\")\n    if not username or not password:\n        abort(400, description=\"Missing username or password\")\n\n    user = USERS.get(username)\n    if not user or user[\"password\"] != password:\n        abort(401, description=\"Invalid credentials\")\n\n    token = create_jwt(user[\"id\"])\n    return jsonify({\"access_token\": token})\n\n\n@app.route(\"/protected\", methods=[\"GET\"])\n@jwt_required\ndef protected(payload):\n    \"\"\"\n    Example protected endpoint.\n\n    The `payload` argument contains the decoded JWT claims.\n    \"\"\"\n    return jsonify({\n        \"message\": \"You have accessed a protected resource.\",\n        \"user_id\": payload[\"sub\"],\n        \"issued_at\": payload[\"iat\"],\n        \"expires_at\": payload[\"exp\"],\n    })\n\n\n# --------------------------------------------------------------------------- #\n# Run the app\n# --------------------------------------------------------------------------- #\nif __name__ == \"__main__\":\n    # In production use a proper WSGI server (gunicorn, uWSGI, etc.)\n    app.run(host=\"0.0.0.0\", port=5000, debug=False)\n```"
}