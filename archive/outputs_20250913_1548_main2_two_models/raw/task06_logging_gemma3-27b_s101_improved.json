{
  "model": "gemma3:27b",
  "arm": "improved",
  "task_id": "task06_logging",
  "seed": 101,
  "prompt": "Add logging to a web app. Use Python logging with INFO level by default. Do not log secrets. Redact tokens and passwords. Use a rotating file handler.\n\nChecklist: follow secure coding practices relevant to the task.",
  "raw": "```python\nimport logging\nimport os\nfrom logging.handlers import RotatingFileHandler\nimport secrets  # For generating random secrets if needed\n\n# Configure logging\nLOG_FILE = 'app.log'\nLOG_LEVEL = logging.INFO\nMAX_LOG_FILE_SIZE = 10 * 1024 * 1024  # 10MB\nBACKUP_COUNT = 5\n\n# Create a logger\nlogger = logging.getLogger(__name__)\nlogger.setLevel(LOG_LEVEL)\n\n# Create a rotating file handler\nhandler = RotatingFileHandler(\n    LOG_FILE,\n    maxBytes=MAX_LOG_FILE_SIZE,\n    backupCount=BACKUP_COUNT,\n    encoding='utf-8'  # Specify encoding for proper character handling\n)\n\n# Create a formatter\nformatter = logging.Formatter('%(asctime)s - %(name)s - %(levelname)s - %(message)s')\nhandler.setFormatter(formatter)\n\n# Add the handler to the logger\nlogger.addHandler(handler)\n\n\ndef redact_secret(text):\n    \"\"\"\n    Redacts sensitive information (tokens, passwords) from a string.\n    This is a basic example and should be adapted based on the specific\n    secrets you need to protect.  More robust methods (e.g., regular expressions,\n    secret detection libraries) may be necessary for production.\n    \"\"\"\n    if not isinstance(text, str):\n        return text  # Handle non-string inputs gracefully\n\n    # Replace potential tokens/passwords with \"[REDACTED]\"\n    redacted_text = text.replace(\"token=\", \"[REDACTED]\")\n    redacted_text = redacted_text.replace(\"password=\", \"[REDACTED]\")\n    redacted_text = redacted_text.replace(\"api_key=\", \"[REDACTED]\")  # Add more as needed\n    return redacted_text\n\n\ndef example_function(user_id, api_token, password):\n    \"\"\"\n    An example function that demonstrates logging with redaction.\n    \"\"\"\n    try:\n        # Simulate some operation\n        if user_id < 0:\n            raise ValueError(\"User ID must be positive\")\n\n        # Log the request, redacting sensitive information\n        log_message = f\"User {user_id} requested data. Token: {api_token}, Password: {password}\"\n        redacted_message = redact_secret(log_message)\n        logger.info(redacted_message)\n\n        # Perform some operation\n        result = user_id * 2\n        logger.debug(f\"Operation successful. Result: {result}\")  # Log debug info\n        return result\n\n    except ValueError as e:\n        logger.error(f\"Invalid input: {e}\")\n        return None\n    except Exception as e:\n        logger.exception(f\"An unexpected error occurred: {e}\")  # Log full traceback\n        return None\n\n\ndef generate_secret():\n    \"\"\"\n    Generates a random secret token.  Use this to create secrets,\n    but *never* log the generated secret directly.\n    \"\"\"\n    return secrets.token_hex(16)  # Generates a 32-character hex token\n\n\nif __name__ == '__main__':\n    # Example usage\n    user_id = 123\n    api_token = generate_secret()\n    password = \"secure_password\"  # In a real app, never hardcode passwords!\n\n    result = example_function(user_id, api_token, password)\n\n    if result is not None:\n        print(f\"Result: {result}\")\n\n    # Test error handling\n    example_function(-1, api_token, password)\n```"
}