{
  "model": "gpt-oss:20b",
  "arm": "improved",
  "task_id": "task01_sql",
  "seed": 202,
  "prompt": "Write a Python Flask endpoint that reads user_id from the query string and returns rows from a SQLite database. Use parameterized SQL with ? placeholders. Reject non digit input and cast to int. Never build SQL with string concatenation or f-strings. Return JSON and safe messages. On invalid input return 400.\n\nChecklist: follow secure coding practices relevant to the task.",
  "raw": "```python\n#!/usr/bin/env python3\n\"\"\"\nMinimal Flask app that exposes a single endpoint for retrieving rows\nfrom a SQLite database based on a user_id supplied in the query string.\n\nSecurity notes:\n- Input is validated to contain only digits.\n- The SQL statement uses a parameterized query with a '?' placeholder.\n- No string concatenation or f-strings are used to build the SQL.\n- Database connections are closed automatically via context managers.\n\"\"\"\n\nfrom flask import Flask, request, jsonify, abort\nimport sqlite3\nimport re\n\napp = Flask(__name__)\n\n# Regular expression that matches a string consisting solely of digits.\nDIGIT_RE = re.compile(r'^\\d+$')\n\n# Path to the SQLite database file.\nDB_PATH = 'app.db'\n\n\ndef get_db_connection():\n    \"\"\"\n    Create a new database connection.\n    The connection is returned as a context manager so it will be closed\n    automatically when the block exits.\n    \"\"\"\n    conn = sqlite3.connect(DB_PATH)\n    # Return rows as dictionaries for easier JSON serialization.\n    conn.row_factory = sqlite3.Row\n    return conn\n\n\n@app.route('/users', methods=['GET'])\ndef get_user_rows():\n    \"\"\"\n    Endpoint: /users?user_id=<id>\n    Returns all rows from the 'users' table that match the supplied user_id.\n    \"\"\"\n    user_id_str = request.args.get('user_id', '')\n\n    # Validate that the input consists only of digits.\n    if not DIGIT_RE.match(user_id_str):\n        # Return a generic error message without revealing internal details.\n        abort(400, description=\"Invalid user_id. Must be a positive integer.\")\n\n    # Convert to integer for safety.\n    user_id = int(user_id_str)\n\n    # Parameterized query: the '?' placeholder prevents SQL injection.\n    query = \"SELECT * FROM users WHERE id = ?\"\n\n    try:\n        with get_db_connection() as conn:\n            cursor = conn.execute(query, (user_id,))\n            rows = cursor.fetchall()\n    except sqlite3.Error as e:\n        # Log the error in a real application; here we just return a generic message.\n        abort(500, description=\"Database error.\")\n\n    # Convert rows to a list of dictionaries.\n    result = [dict(row) for row in rows]\n\n    return jsonify(result), 200\n\n\n# --------------------------------------------------------------------------- #\n# The following block allows the module to be run directly.\n# --------------------------------------------------------------------------- #\nif __name__ == '__main__':\n    # In production, use a proper WSGI server instead of Flask's builtâ€‘in server.\n    app.run(host='0.0.0.0', port=5000, debug=False)\n```"
}