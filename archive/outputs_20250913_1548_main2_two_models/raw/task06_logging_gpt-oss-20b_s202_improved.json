{
  "model": "gpt-oss:20b",
  "arm": "improved",
  "task_id": "task06_logging",
  "seed": 202,
  "prompt": "Add logging to a web app. Use Python logging with INFO level by default. Do not log secrets. Redact tokens and passwords. Use a rotating file handler.\n\nChecklist: follow secure coding practices relevant to the task.",
  "raw": "```python\n#!/usr/bin/env python3\n\"\"\"\nMinimal Flask web application with secure logging.\n\nFeatures:\n- INFO level logging by default.\n- Rotating file handler (10 MB per file, 5 backups).\n- Redacts secrets (passwords, tokens, API keys, etc.) from logs.\n- Does not log environment secrets.\n- Uses a custom logging filter to scrub log messages.\n\nAuthor: Senior Python Engineer\n\"\"\"\n\nimport os\nimport re\nimport logging\nfrom logging.handlers import RotatingFileHandler\nfrom flask import Flask, request, jsonify\n\n# --------------------------------------------------------------------------- #\n# Configuration\n# --------------------------------------------------------------------------- #\n\n# Log file location – can be overridden by the LOG_FILE environment variable.\nLOG_FILE = os.getenv(\"LOG_FILE\", \"app.log\")\n\n# Maximum size of a single log file (bytes) before rotation.\nMAX_BYTES = 10 * 1024 * 1024  # 10 MB\n\n# Number of backup log files to keep.\nBACKUP_COUNT = 5\n\n# List of keys that should be redacted when logging dictionaries.\nSECRET_KEYS = {\n    \"password\",\n    \"token\",\n    \"api_key\",\n    \"secret\",\n    \"key\",\n    \"access_token\",\n    \"refresh_token\",\n    \"authorization\",\n    \"auth\",\n}\n\n# Regular expression to find token-like patterns in strings.\nTOKEN_REGEX = re.compile(\n    r\"\"\"\n    (?P<key>token|access_token|refresh_token|authorization|auth)\\s*[:=]\\s*\n    (?P<value>[^\\s,]+)\n    \"\"\",\n    re.IGNORECASE | re.VERBOSE,\n)\n\n# --------------------------------------------------------------------------- #\n# Helper functions\n# --------------------------------------------------------------------------- #\n\ndef redact_dict(data):\n    \"\"\"\n    Recursively redact sensitive keys in a dictionary.\n    Returns a new dictionary with secrets replaced by '[REDACTED]'.\n    \"\"\"\n    if not isinstance(data, dict):\n        return data\n    redacted = {}\n    for k, v in data.items():\n        if k.lower() in SECRET_KEYS:\n            redacted[k] = \"[REDACTED]\"\n        else:\n            redacted[k] = redact_dict(v) if isinstance(v, dict) else v\n    return redacted\n\ndef redact_string(text):\n    \"\"\"\n    Redact token-like patterns in a string.\n    \"\"\"\n    def repl(match):\n        return f\"{match.group('key')}=[REDACTED]\"\n    return TOKEN_REGEX.sub(repl, text)\n\nclass RedactFilter(logging.Filter):\n    \"\"\"\n    Logging filter that redacts secrets from log messages.\n    \"\"\"\n    def filter(self, record):\n        # Redact message\n        record.msg = redact_string(record.msg)\n        # Redact any dict in the record's args\n        if isinstance(record.args, dict):\n            record.args = redact_dict(record.args)\n        return True\n\n# --------------------------------------------------------------------------- #\n# Logging setup\n# --------------------------------------------------------------------------- #\n\ndef setup_logging():\n    \"\"\"\n    Configure the root logger with a rotating file handler and redaction filter.\n    \"\"\"\n    logger = logging.getLogger()\n    logger.setLevel(logging.INFO)\n\n    # Rotating file handler\n    handler = RotatingFileHandler(\n        LOG_FILE, maxBytes=MAX_BYTES, backupCount=BACKUP_COUNT\n    )\n    formatter = logging.Formatter(\n        fmt=\"%(asctime)s [%(levelname)s] %(name)s: %(message)s\",\n        datefmt=\"%Y-%m-%d %H:%M:%S\",\n    )\n    handler.setFormatter(formatter)\n    handler.addFilter(RedactFilter())\n\n    logger.addHandler(handler)\n\n# --------------------------------------------------------------------------- #\n# Flask application\n# --------------------------------------------------------------------------- #\n\napp = Flask(__name__)\n\n@app.before_request\ndef log_request_info():\n    \"\"\"\n    Log incoming request details, redacting sensitive data.\n    \"\"\"\n    logger = logging.getLogger(\"app.request\")\n    # Redact headers that may contain secrets\n    headers = {\n        k: v for k, v in request.headers.items()\n        if k.lower() != \"authorization\"\n    }\n    # Redact JSON body if present\n    if request.is_json:\n        try:\n            body = request.get_json(silent=True) or {}\n            body = redact_dict(body)\n        except Exception:\n            body = \"[UNABLE TO PARSE JSON]\"\n    else:\n        body = request.get_data(as_text=True)\n        body = redact_string(body)\n\n    logger.info(\n        \"Incoming request\",\n        extra={\n            \"method\": request.method,\n            \"path\": request.path,\n            \"headers\": headers,\n            \"body\": body,\n        },\n    )\n\n@app.after_request\ndef log_response_info(response):\n    \"\"\"\n    Log outgoing response status.\n    \"\"\"\n    logger = logging.getLogger(\"app.response\")\n    logger.info(\n        \"Response\",\n        extra={\n            \"status\": response.status,\n            \"headers\": dict(response.headers),\n        },\n    )\n    return response\n\n@app.route(\"/login\", methods=[\"POST\"])\ndef login():\n    \"\"\"\n    Example endpoint that accepts JSON with a password and token.\n    The values are redacted in the logs.\n    \"\"\"\n    data = request.get_json() or {}\n    # In a real app, you would authenticate here.\n    return jsonify({\"message\": \"Login successful\"}), 200\n\n# --------------------------------------------------------------------------- #\n# Main entry point\n# --------------------------------------------------------------------------- #\n\nif __name__ == \"__main__\":\n    setup_logging()\n    # Run the Flask development server (not for production use).\n    app.run(host=\"0.0.0.0\", port=5000, debug=False)\n```"
}