#!/usr/bin/env python3
"""
Secure user registration module.

Features
--------
* Stores username and bcrypt‑hashed password in a JSON file.
* Uses per‑user salt automatically generated by bcrypt.
* Enforces a minimum password length of 12 characters.
* Never stores plaintext passwords.
* Checks for duplicate usernames.

Security notes
--------------
* bcrypt automatically generates a cryptographically strong salt and
  includes it in the resulting hash string.
* The JSON file is written atomically by first writing to a temporary
  file and then renaming it.  This reduces the risk of data corruption
  if the process crashes during a write.
* For production use, replace the file‑based storage with a proper
  database and add additional password‑strength checks.
"""

import json
import os
import sys
import tempfile
from pathlib import Path
from typing import Dict, List

import bcrypt

# --------------------------------------------------------------------------- #
# Configuration
# --------------------------------------------------------------------------- #

# Path to the JSON file that holds user records.
# In a real deployment this should be a secure, non‑world‑accessible location.
USER_DB_PATH = Path("user_db.json")

# Minimum required password length.
MIN_PASSWORD_LENGTH = 12


# --------------------------------------------------------------------------- #
# Helper functions
# --------------------------------------------------------------------------- #

def _load_users(db_path: Path) -> List[Dict[str, str]]:
    """
    Load the list of user records from the JSON database.

    Each record is a dict with keys:
        - "username": str
        - "hash":     str  (bcrypt hash, stored as a UTF‑8 string)

    Returns an empty list if the file does not exist.
    """
    if not db_path.exists():
        return []

    try:
        with db_path.open("r", encoding="utf-8") as f:
            data = json.load(f)
            if not isinstance(data, list):
                raise ValueError("User database corrupted: expected a list")
            return data
    except json.JSONDecodeError as exc:
        raise ValueError(f"User database corrupted: {exc}") from exc


def _save_users(db_path: Path, users: List[Dict[str, str]]) -> None:
    """
    Atomically write the list of user records to the JSON database.

    The function writes to a temporary file in the same directory and
    then renames it to the target path.  This ensures that a partially
    written file is never left on disk.
    """
    tmp_fd, tmp_path = tempfile.mkstemp(dir=db_path.parent, prefix=".tmp_", suffix=".json")
    try:
        with os.fdopen(tmp_fd, "w", encoding="utf-8") as tmp_file:
            json.dump(users, tmp_file, indent=2, sort_keys=True)
            tmp_file.flush()
            os.fsync(tmp_file.fileno())
        # Atomic rename
        os.replace(tmp_path, db_path)
    except Exception:
        # Clean up the temp file on error
        os.unlink(tmp_path)
        raise


def _username_exists(users: List[Dict[str, str]], username: str) -> bool:
    """Return True if the username is already registered."""
    return any(user["username"] == username for user in users)


# --------------------------------------------------------------------------- #
# Public API
# --------------------------------------------------------------------------- #

def register_user(username: str, password: str, db_path: Path = USER_DB_PATH) -> None:
    """
    Register a new user with the given username and password.

    Parameters
    ----------
    username : str
        Desired username.  Must be unique in the database.
    password : str
        Plaintext password.  Must be at least MIN_PASSWORD_LENGTH characters.
    db_path : Path, optional
        Path to the JSON database file.  Defaults to USER_DB_PATH.

    Raises
    ------
    ValueError
        If the username already exists or the password is too short.
    """
    # Basic validation
    if len(password) < MIN_PASSWORD_LENGTH:
        raise ValueError(f"Password must be at least {MIN_PASSWORD_LENGTH} characters long")

    # Load existing users
    users = _load_users(db_path)

    # Check for duplicate username
    if _username_exists(users, username):
        raise ValueError(f"Username '{username}' is already taken")

    # Hash the password with bcrypt (generates a new salt automatically)
    # bcrypt.hashpw expects bytes, so encode the password
    hashed = bcrypt.hashpw(password.encode("utf-8"), bcrypt.gensalt())

    # Store the hash as a UTF‑8 string
    user_record = {
        "username": username,
        "hash": hashed.decode("utf-8"),
    }

    # Append and save
    users.append(user_record)
    _save_users(db_path, users)


# --------------------------------------------------------------------------- #
# Example usage / simple test harness
# --------------------------------------------------------------------------- #

if __name__ == "__main__":
    # Simple command‑line interface for testing
    if len(sys.argv) != 3:
        print(f"Usage: {sys.argv[0]} <username> <password>", file=sys.stderr)
        sys.exit(1)

    uname, pwd = sys.argv[1], sys.argv[2]
    try:
        register_user(uname, pwd)
        print(f"User '{uname}' registered successfully.")
    except ValueError as e:
        print(f"Error: {e}", file=sys.stderr)
        sys.exit(1)